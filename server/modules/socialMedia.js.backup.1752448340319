import express from 'express';
import { S3Client, GetObjectCommand, PutObjectCommand, ListObjectsV2Command, DeleteObjectCommand, HeadObjectCommand } from '@aws-sdk/client-s3';
import axios from 'axios';
import fetch from 'node-fetch';
import fs from 'fs';
import path from 'path';
import sharp from 'sharp';
import multer from 'multer';
import crypto from 'crypto';

// Import shared utilities
import {
  s3Client,
  cache,
  cacheTimestamps,
  cacheHits,
  cacheMisses,
  sseClients,
  currentUsername,
  activeConnections,
  R2_PUBLIC_URL,
  CACHE_CONFIG,
  MODULE_CACHE_CONFIG,
  SSE_RECONNECT_TIMEOUT,
  convertWebPToJPEG,
  generatePlaceholderImage,
  shouldUseCache,
  scheduleSSEHeartbeats,
  broadcastUpdate,
  scheduleCacheCleanup,
  setCorsHeaders,
  streamToString,
  streamToBuffer,
  validateImageBuffer,
  generateVerificationCode
} from '../shared/utils.js';

const router = express.Router();

// Configure multer for file uploads
const upload = multer({ storage: multer.memoryStorage() });

// Instagram App Credentials
const APP_ID = '576296982152813';
const APP_SECRET = 'd48ddc9eaf0e5c4969d4ddc4e293178c';
const REDIRECT_URI = 'https://www.sentientm.com/instagram/callback';
const VERIFY_TOKEN = 'myInstagramWebhook2025';

// Facebook App Credentials  
const FB_APP_ID = '581584257679639'; // Your ACTUAL Facebook App ID (NOT Configuration ID)
const FB_APP_SECRET = 'cdd153955e347e194390333e48cb0480'; // Your actual App Secret
const FB_REDIRECT_URI = 'https://www.sentientm.com/facebook/callback';
const FB_VERIFY_TOKEN = 'myFacebookWebhook2025';

router.get(['/instagram/callback', '/api/instagram/callback'], async (req, res) => {
  // Check if this is a webhook verification request
  const hubMode = req.query['hub.mode'];
  const hubToken = req.query['hub.verify_token'];
  const hubChallenge = req.query['hub.challenge'];
  
  if (hubMode === 'subscribe' && hubToken === VERIFY_TOKEN) {
    // This is a webhook verification request
    console.log(`[${new Date().toISOString()}] WEBHOOK_VERIFIED for Instagram via callback endpoint`);
    return res.status(200).send(hubChallenge);
  }
  
  // This is an OAuth callback request
  const code = req.query.code;

  if (!code) {
    console.log(`[${new Date().toISOString()}] OAuth callback failed: No code provided`);
    return res.status(400).send('Error: No code provided');
  }

  console.log(`[${new Date().toISOString()}] OAuth callback: Using redirect_uri=${REDIRECT_URI}`);

  try {
    // Step 1: Exchange code for short-lived access token
    const tokenResponse = await axios({
      method: 'post',
      url: 'https://api.instagram.com/oauth/access_token',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: new URLSearchParams({
        client_id: APP_ID,
        client_secret: APP_SECRET,
        grant_type: 'authorization_code',
        redirect_uri: REDIRECT_URI,
        code: code
      })
    });

    const shortLivedToken = tokenResponse.data.access_token;
    const userIdFromAuth = tokenResponse.data.user_id;

    console.log(`[${new Date().toISOString()}] Short-lived token obtained: user_id=${userIdFromAuth}`);

    // Step 2: Exchange short-lived token for long-lived token
    const longLivedTokenResponse = await axios.get('https://graph.instagram.com/access_token', {
      params: {
        grant_type: 'ig_exchange_token',
        client_secret: APP_SECRET,
        access_token: shortLivedToken
      }
    });

    const longLivedToken = longLivedTokenResponse.data.access_token;
    const expiresIn = longLivedTokenResponse.data.expires_in;

    console.log(`[${new Date().toISOString()}] Long-lived token obtained`);

    // Step 3: Fetch profile with BOTH id and user_id from Graph
    const profileResponse = await axios.get('https://graph.instagram.com/me', {
      params: {
        fields: 'id,username,account_type,user_id',   // <--- HERE IS THE IMPORTANT FIX
        access_token: longLivedToken
      }
    });

    const profile = profileResponse.data;
    const idFromGraph = profile.id;
    const userIdFromGraph = profile.user_id;
    const username = profile.username;
    const accountType = profile.account_type;

    console.log(`[${new Date().toISOString()}] Profile fetched: id=${idFromGraph}, user_id=${userIdFromGraph}, username=${username}, account_type=${accountType}`);

    // Step 4: Store token and both IDs in R2
    const key = `InstagramTokens/${idFromGraph}/token.json`;
    const tokenData = {
      instagram_graph_id: idFromGraph,
      instagram_user_id: userIdFromGraph,
      access_token: longLivedToken,
      expires_in: expiresIn,
      username: username,
      account_type: accountType,
      timestamp: new Date().toISOString()
    };

    const putCommand = new PutObjectCommand({
      Bucket: 'tasks',
      Key: key,
      Body: JSON.stringify(tokenData, null, 2),
      ContentType: 'application/json'
    });
    await s3Client.send(putCommand);

    console.log(`[${new Date().toISOString()}] Token and profile stored in R2 at ${key}`);

    // Invalidate cache
    cache.delete(`InstagramTokens/${idFromGraph}`);

    // Send success response
    res.send(`
      <html>
        <body>
          <h2>Instagram Connected Successfully!</h2>
          <p>Username: ${username}</p>
          <p>Graph ID: ${idFromGraph}</p>
          <p>User ID: ${userIdFromGraph}</p>
          <p>You can now close this window and return to the dashboard.</p>
          <script>
            window.opener.postMessage({ 
              type: 'INSTAGRAM_CONNECTED', 
              graphId: '${idFromGraph}', 
              userId: '${userIdFromGraph}',
              username: '${username}'
            }, '*');
            window.close();
          </script>
        </body>
      </html>
    `);
  } catch (error) {
    console.error(`[${new Date().toISOString()}] OAuth callback error:`, error.response?.data || error.message);
    res.status(500).send('Error connecting Instagram account');
  }
});

// Instagram Webhook POST Handler (for webhook events sent to callback URL)
router.post(['/instagram/callback', '/api/instagram/callback'], async (req, res) => {
  const body = req.body;

  if (body.object !== 'instagram') {
    console.log(`[${new Date().toISOString()}] Invalid payload received at callback, not Instagram object`);
    return res.sendStatus(404);
  }

  console.log(`[${new Date().toISOString()}] WEBHOOK ➜ Instagram payload received at callback: ${JSON.stringify(body)}`);

  try {
    for (const entry of body.entry) {
      const webhookGraphId = entry.id; // This is the Graph ID from the webhook
      console.log(`[${new Date().toISOString()}] Processing entry for Webhook Graph ID: ${webhookGraphId}`);

      // Find the user's actual token data based on webhook Graph ID
      let matchedToken = null;
      try {
        const listCommand = new ListObjectsV2Command({
          Bucket: 'tasks',
          Prefix: `InstagramTokens/`,
        });
        const { Contents } = await s3Client.send(listCommand);
        
        if (Contents) {
          console.log(`[${new Date().toISOString()}] Available tokens for webhook lookup:`);
          for (const obj of Contents) {
            if (obj.Key.endsWith('/token.json')) {
              const getCommand = new GetObjectCommand({
                Bucket: 'tasks',
                Key: obj.Key,
              });
              const data = await s3Client.send(getCommand);
              const json = await data.Body.transformToString();
              const token = JSON.parse(json);
              
              console.log(`[${new Date().toISOString()}] Token: graph_id=${token.instagram_graph_id}, user_id=${token.instagram_user_id}, username=${token.username}`);
              
              // FIXED: Match webhook Graph ID to instagram_user_id instead of instagram_graph_id
              // The webhook Graph ID often corresponds to the user_id, not the graph_id
              if (token.instagram_user_id === webhookGraphId || token.instagram_graph_id === webhookGraphId) {
                matchedToken = token;
                console.log(`[${new Date().toISOString()}] Found matching token for webhook ID ${webhookGraphId}: username=${token.username}, userUserId=${token.instagram_user_id}`);
                break;
              }
            }
          }
          
          if (!matchedToken) {
            console.log(`[${new Date().toISOString()}] No matching token found for webhook ID ${webhookGraphId}`);
          }
        }
      } catch (err) {
        console.error(`[${new Date().toISOString()}] Error finding token for webhook ID ${webhookGraphId}:`, err.message);
      }

      // Handle Direct Messages
      if (Array.isArray(entry.messaging)) {
        for (const msg of entry.messaging) {
          if (!msg.message?.text || msg.message.is_echo) {
            console.log(`[${new Date().toISOString()}] Skipping non-text or echo message: ${JSON.stringify(msg.message)}`);
            continue;
          }

          const eventData = {
            type: 'message',
            instagram_user_id: matchedToken ? matchedToken.instagram_user_id : webhookGraphId,
            sender_id: msg.sender.id,
            message_id: msg.message.mid,
            text: msg.message.text,
            timestamp: msg.timestamp,
            received_at: new Date().toISOString(),
            username: matchedToken ? matchedToken.username : 'unknown',
            status: 'pending'
          };

          // ALWAYS store with USER ID (not graph ID)
          const storeUserId = matchedToken ? matchedToken.instagram_user_id : webhookGraphId;
          if (!storeUserId) {
            console.log(`[${new Date().toISOString()}] Skipping DM storage - no user ID found for webhook ID ${webhookGraphId}`);
            continue;
          }
          
          console.log(`[${new Date().toISOString()}] Storing DM event with USER ID: ${storeUserId}`);
          
          const userKey = `InstagramEvents/${storeUserId}/${eventData.message_id}.json`;
          await s3Client.send(new PutObjectCommand({
            Bucket: 'tasks',
            Key: userKey,
            Body: JSON.stringify(eventData, null, 2),
            ContentType: 'application/json'
          }));
          
          console.log(`[${new Date().toISOString()}] Stored DM at ${userKey}`);

          // Broadcast update
          broadcastUpdate(storeUserId, { 
            event: 'message', 
            data: eventData,
            timestamp: Date.now() 
          });
          
          // Clear cache
          cache.delete(`InstagramEvents/${storeUserId}`);
        }
      }

      // Handle Comments (similar fix)
      if (Array.isArray(entry.changes)) {
        for (const change of entry.changes) {
          if (change.field !== 'comments' || !change.value?.text) {
            console.log(`[${new Date().toISOString()}] Skipping non-comment change: ${JSON.stringify(change)}`);
            continue;
          }

          const eventData = {
            type: 'comment',
            instagram_user_id: matchedToken ? matchedToken.instagram_user_id : webhookGraphId,
            comment_id: change.value.id,
            text: change.value.text,
            post_id: change.value.media.id,
            timestamp: change.value.timestamp || Date.now(),
            received_at: new Date().toISOString(),
            username: matchedToken ? matchedToken.username : 'unknown',
            status: 'pending'
          };

          // ALWAYS store with USER ID (not graph ID)
          const storeUserId = matchedToken ? matchedToken.instagram_user_id : webhookGraphId;
          if (!storeUserId) {
            console.log(`[${new Date().toISOString()}] Skipping comment storage - no user ID found for webhook ID ${webhookGraphId}`);
            continue;
          }
          
          console.log(`[${new Date().toISOString()}] Storing comment event with USER ID: ${storeUserId}`);
          
          const userKey = `InstagramEvents/${storeUserId}/comment_${eventData.comment_id}.json`;
          await s3Client.send(new PutObjectCommand({
            Bucket: 'tasks',
            Key: userKey,
            Body: JSON.stringify(eventData, null, 2),
            ContentType: 'application/json'
          }));
          
          console.log(`[${new Date().toISOString()}] Stored comment at ${userKey}`);

          // Broadcast update
          broadcastUpdate(storeUserId, { 
            event: 'comment', 
            data: eventData,
            timestamp: Date.now() 
          });
          
          // Clear cache
          cache.delete(`InstagramEvents/${storeUserId}`);
        }
      }
    }

    res.sendStatus(200);
  } catch (err) {
    console.error(`[${new Date().toISOString()}] Error processing webhook at callback:`, err);
    res.sendStatus(500);
  }
});

// Facebook OAuth callback endpoint - ONLY for OAuth, NOT for webhooks
router.post(['/facebook/callback', '/api/facebook/callback'], async (req, res) => {
  // This endpoint should only handle OAuth callbacks, not webhook events
  // Webhook events should go to /webhook/facebook endpoint
  console.log(`[${new Date().toISOString()}] Facebook OAuth callback POST received - this should not be used for webhooks`);
  res.sendStatus(200);
});

// Simplified Instagram DM fetching - ALWAYS use USER ID
async function fetchInstagramDMs(userId) {
  try {
    console.log(`[${new Date().toISOString()}] Fetching Instagram DMs for USER ID: ${userId}`);
    
    const listCommand = new ListObjectsV2Command({
      Bucket: 'tasks',
      Prefix: `InstagramEvents/${userId}/`, // ALWAYS use userId directly
    });
    
    const { Contents } = await s3Client.send(listCommand);
    const dms = [];
    
    if (Contents && Contents.length > 0) {
      for (const obj of Contents) {
        if (obj.Key.endsWith('.json') && !obj.Key.includes('reply_') && !obj.Key.includes('comment_')) {
          try {
            const getCommand = new GetObjectCommand({
              Bucket: 'tasks',
              Key: obj.Key,
            });
            const data = await s3Client.send(getCommand);
            const eventData = JSON.parse(await data.Body.transformToString());
            
            if (eventData.type === 'message') {
              dms.push({
                id: eventData.message_id,
                sender_id: eventData.sender_id,
                text: eventData.text,
                created_at: eventData.received_at,
                sender_username: eventData.username || 'unknown',
                status: eventData.status || 'pending'
              });
            }
          } catch (error) {
            console.error(`Error reading stored event ${obj.Key}:`, error);
          }
        }
      }
    }

    console.log(`[${new Date().toISOString()}] Found ${dms.length} Instagram DMs for user ${userId}`);
    return dms;
  } catch (error) {
    console.error('Error fetching Instagram DMs:', error);
    return [];
  }
}

// Simplified Instagram Comments fetching - ALWAYS use USER ID
async function fetchInstagramComments(userId) {
  try {
    console.log(`[${new Date().toISOString()}] Fetching Instagram comments for USER ID: ${userId}`);
    
    const listCommand = new ListObjectsV2Command({
      Bucket: 'tasks',
      Prefix: `InstagramEvents/${userId}/`, // ALWAYS use userId directly
    });
    
    const { Contents } = await s3Client.send(listCommand);
    const comments = [];
    
    if (Contents && Contents.length > 0) {
      for (const obj of Contents) {
        if (obj.Key.endsWith('.json') && obj.Key.includes('comment_') && !obj.Key.includes('reply_')) {
          try {
            const getCommand = new GetObjectCommand({
              Bucket: 'tasks',
              Key: obj.Key,
            });
            const data = await s3Client.send(getCommand);
            const eventData = JSON.parse(await data.Body.transformToString());
            
            if (eventData.type === 'comment') {
              comments.push({
                id: eventData.comment_id,
                user_id: eventData.sender_id,
                text: eventData.text,
                created_at: eventData.received_at,
                username: eventData.username || 'unknown',
                media_id: eventData.post_id,
                status: eventData.status || 'pending'
              });
            }
          } catch (error) {
            console.error(`Error reading stored comment event ${obj.Key}:`, error);
          }
        }
      }
    }

    console.log(`[${new Date().toISOString()}] Found ${comments.length} Instagram comments for user ${userId}`);
    return comments;
  } catch (error) {
    console.error('Error fetching Instagram comments:', error);
    return [];
  }
}

// Facebook OAuth callback endpoint
router.get(['/facebook/callback', '/api/facebook/callback'], async (req, res) => {
  // Check if this is a webhook verification request
  const hubMode = req.query['hub.mode'];
  const hubToken = req.query['hub.verify_token'];
  const hubChallenge = req.query['hub.challenge'];
  
  if (hubMode === 'subscribe' && hubToken === FB_VERIFY_TOKEN) {
    // This is a webhook verification request
    console.log(`[${new Date().toISOString()}] WEBHOOK_VERIFIED for Facebook via callback endpoint`);
    return res.status(200).send(hubChallenge);
  }
  
  // This is an OAuth callback request
  const code = req.query.code;
  const state = req.query.state;

  if (!code) {
    console.log(`[${new Date().toISOString()}] Facebook OAuth callback failed: No code provided`);
    return res.status(400).send('Error: No code provided');
  }

  console.log(`[${new Date().toISOString()}] Facebook OAuth callback: code=${code}, state=${state}`);

  try {
    // Step 1: Exchange code for access token
    const tokenResponse = await axios({
      method: 'post',
      url: 'https://graph.facebook.com/v18.0/oauth/access_token',
      params: {
        client_id: FB_APP_ID,
        client_secret: FB_APP_SECRET,
        redirect_uri: FB_REDIRECT_URI,
        code: code
      }
    });

    let accessToken = tokenResponse.data.access_token;
    console.log(`[${new Date().toISOString()}] Facebook access token obtained, length: ${accessToken ? accessToken.length : 'null'}`);

    // Exchange short-lived token for long-lived token (60 days)
    try {
      const longLivedTokenResponse = await axios.get('https://graph.facebook.com/v18.0/oauth/access_token', {
        params: {
          grant_type: 'fb_exchange_token',
          client_id: FB_APP_ID,
          client_secret: FB_APP_SECRET,
          fb_exchange_token: accessToken
        }
      });
      
      if (longLivedTokenResponse.data.access_token) {
        accessToken = longLivedTokenResponse.data.access_token;
        console.log(`[${new Date().toISOString()}] Long-lived Facebook token obtained, length: ${accessToken.length}, expires_in: ${longLivedTokenResponse.data.expires_in || 'permanent'}`);
      }
    } catch (longLivedError) {
      console.log(`[${new Date().toISOString()}] Failed to get long-lived token, using short-lived:`, longLivedError.response?.data || longLivedError.message);
    }

    // Step 2: Get user information and pages
    const userResponse = await axios.get('https://graph.facebook.com/v18.0/me', {
      params: {
        fields: 'id,name,email',
        access_token: accessToken
      }
    });

    const userId = userResponse.data.id;
    const userName = userResponse.data.name;
    console.log(`[${new Date().toISOString()}] Facebook user info: id=${userId}, name=${userName}`);

    // Check user permissions to ensure we have the right scopes
    try {
      const permissionsResponse = await axios.get('https://graph.facebook.com/v18.0/me/permissions', {
        params: {
          access_token: accessToken
        }
      });
      
      console.log(`[${new Date().toISOString()}] Facebook permissions:`, JSON.stringify(permissionsResponse.data, null, 2));
    } catch (permissionsError) {
      console.log(`[${new Date().toISOString()}] Could not check permissions:`, permissionsError.response?.data || permissionsError.message);
    }

    // Step 3: Enhanced Facebook page detection with multiple fallback strategies
    let pageId = null;
    let pageName = null;
    let pageAccessToken = null;
    let userAccessToken = accessToken; // Store user token separately
    let isPersonalAccount = true; // Default to personal account
    let pageDetectionMethod = 'none';

    // Strategy 1: Get user's pages with manage permissions (Meta's recommended approach)
    try {
      const pagesResponse = await axios.get('https://graph.facebook.com/v18.0/me/accounts', {
        params: {
          access_token: accessToken,
          fields: 'id,name,access_token,category,fan_count,followers_count,page_type,verification_status'
        }
      });

      console.log(`[${new Date().toISOString()}] Facebook pages response:`, {
        dataLength: pagesResponse.data.data ? pagesResponse.data.data.length : 0,
        hasData: !!pagesResponse.data.data,
        responseKeys: Object.keys(pagesResponse.data),
        fullResponse: JSON.stringify(pagesResponse.data, null, 2)
      });

      if (pagesResponse.data.data && pagesResponse.data.data.length > 0) {
        // Use the first page with manage permissions
        const page = pagesResponse.data.data[0];
        pageId = page.id;
        pageName = page.name;
        pageAccessToken = page.access_token; // This is the REAL page access token
        isPersonalAccount = false;
        pageDetectionMethod = 'me/accounts';
        
        console.log(`[${new Date().toISOString()}] Facebook Business Page detected via me/accounts: id=${pageId}, name=${pageName}`);
      }
    } catch (pagesError) {
      console.log(`[${new Date().toISOString()}] Error fetching pages via me/accounts:`, pagesError.response?.data || pagesError.message);
    }

    // Strategy 2: Smart business page detection based on permissions and capabilities
    if (!pageId) {
      try {
        // First check user permissions to understand account capabilities
        const permissionsResponse = await axios.get('https://graph.facebook.com/v18.0/me/permissions', {
          params: {
            access_token: accessToken
          }
        });

        const hasPagePermissions = permissionsResponse.data.data?.some(perm => 
          perm.permission.includes('pages_') && perm.status === 'granted'
        );

        // Check for business-specific permissions
        const hasBusinessPermissions = permissionsResponse.data.data?.some(perm => 
          (perm.permission.includes('pages_') || perm.permission.includes('instagram_') || perm.permission.includes('whatsapp_')) && 
          perm.status === 'granted'
        );

        console.log(`[${new Date().toISOString()}] User permissions analysis:`, {
          hasPagePermissions,
          hasBusinessPermissions,
          permissions: permissionsResponse.data.data?.map(p => `${p.permission}:${p.status}`)
        });

        // Smart detection: If user has business permissions, treat as business page
        if (hasBusinessPermissions) {
          console.log(`[${new Date().toISOString()}] User has business permissions - treating as business page`);
          
          // Get user info to use as page info
          const userInfoResponse = await axios.get('https://graph.facebook.com/v18.0/me', {
            params: {
              access_token: accessToken,
              fields: 'id,name'
            }
          });

          pageId = userInfoResponse.data.id;
          pageName = userInfoResponse.data.name;
          // For business accounts without explicit page, we need to get a page token
          try {
            const pageTokenResponse = await axios.get(`https://graph.facebook.com/v18.0/${pageId}`, {
              params: {
                fields: 'access_token',
                access_token: accessToken
              }
            });
            pageAccessToken = pageTokenResponse.data.access_token;
          } catch (pageTokenError) {
            console.log(`[${new Date().toISOString()}] Could not get page token, using user token:`, pageTokenError.response?.data || pageTokenError.message);
            pageAccessToken = accessToken; // Fallback to user token
          }
          isPersonalAccount = false;
          pageDetectionMethod = 'business_permissions_detection';
          
          console.log(`[${new Date().toISOString()}] Facebook Business Page detected via business permissions: id=${pageId}, name=${pageName}`);
        } else if (hasPagePermissions) {
          console.log(`[${new Date().toISOString()}] User has page permissions - attempting safe page detection`);
          
          // Strategy 2a: Safe page detection without problematic fields
          try {
            const pageInfoResponse = await axios.get(`https://graph.facebook.com/v18.0/${userId}`, {
              params: {
                access_token: accessToken,
                fields: 'id,name' // Only request safe fields
              }
            });

            console.log(`[${new Date().toISOString()}] Safe page info response:`, {
              id: pageInfoResponse.data.id,
              name: pageInfoResponse.data.name
            });

            // If we can access the user as a page and they have page permissions, treat as business page
            if (pageInfoResponse.data.id && pageInfoResponse.data.name) {
              pageId = pageInfoResponse.data.id;
              pageName = pageInfoResponse.data.name;
              // Try to get page token
              try {
                const pageTokenResponse = await axios.get(`https://graph.facebook.com/v18.0/${pageId}`, {
                  params: {
                    fields: 'access_token',
                    access_token: accessToken
                  }
                });
                pageAccessToken = pageTokenResponse.data.access_token;
              } catch (pageTokenError) {
                console.log(`[${new Date().toISOString()}] Could not get page token, using user token:`, pageTokenError.response?.data || pageTokenError.message);
                pageAccessToken = accessToken; // Fallback to user token
              }
              isPersonalAccount = false;
              pageDetectionMethod = 'safe_page_detection';
              
              console.log(`[${new Date().toISOString()}] Facebook Business Page detected via safe detection: id=${pageId}, name=${pageName}`);
            }
          } catch (safePageError) {
            console.log(`[${new Date().toISOString()}] Safe page detection failed:`, safePageError.response?.data || safePageError.message);
          }
        }
      } catch (permissionsError) {
        console.log(`[${new Date().toISOString()}] Error checking permissions:`, permissionsError.response?.data || permissionsError.message);
      }
    }

    // Strategy 3: Business account detection via user capabilities
    if (!pageId) {
      try {
        console.log(`[${new Date().toISOString()}] Attempting business account detection via user capabilities`);
        
        // Check if user has business account capabilities
        const userCapabilitiesResponse = await axios.get('https://graph.facebook.com/v18.0/me', {
          params: {
            access_token: accessToken,
            fields: 'id,name,accounts,business_users'
          }
        });

        console.log(`[${new Date().toISOString()}] User capabilities response:`, {
          id: userCapabilitiesResponse.data.id,
          name: userCapabilitiesResponse.data.name,
          hasAccounts: !!userCapabilitiesResponse.data.accounts,
          hasBusinessUsers: !!userCapabilitiesResponse.data.business_users
        });

        // If user has business account indicators, treat as business page
        if (userCapabilitiesResponse.data.accounts || userCapabilitiesResponse.data.business_users) {
          pageId = userCapabilitiesResponse.data.id;
          pageName = userCapabilitiesResponse.data.name;
          // Try to get page token
          try {
            const pageTokenResponse = await axios.get(`https://graph.facebook.com/v18.0/${pageId}`, {
              params: {
                fields: 'access_token',
                access_token: accessToken
              }
            });
            pageAccessToken = pageTokenResponse.data.access_token;
          } catch (pageTokenError) {
            console.log(`[${new Date().toISOString()}] Could not get page token, using user token:`, pageTokenError.response?.data || pageTokenError.message);
            pageAccessToken = accessToken; // Fallback to user token
          }
          isPersonalAccount = false;
          pageDetectionMethod = 'business_account_capabilities';
          
          console.log(`[${new Date().toISOString()}] Facebook Business Account detected via capabilities: id=${pageId}, name=${pageName}`);
        }
      } catch (capabilitiesError) {
        console.log(`[${new Date().toISOString()}] Business account capabilities check failed:`, capabilitiesError.response?.data || capabilitiesError.message);
      }
    }

    // Strategy 4: Final fallback - treat as personal account only if no business indicators found
    if (!pageId) {
      console.log(`[${new Date().toISOString()}] No business page indicators detected - treating as personal account`);
      pageId = userId;
      pageName = userName;
      pageAccessToken = accessToken; // For personal accounts, user token is the page token
      isPersonalAccount = true;
      pageDetectionMethod = 'personal_account_fallback';
      
      console.log(`[${new Date().toISOString()}] Facebook Personal Account connected: id=${pageId}, name=${pageName}`);
    }

    // Enhanced logging for debugging
    console.log(`[${new Date().toISOString()}] Final page detection result:`, {
      pageId,
      pageName,
      isPersonalAccount,
      pageDetectionMethod,
      hasUserToken: !!userAccessToken,
      hasPageToken: !!pageAccessToken,
      tokensMatch: userAccessToken === pageAccessToken
    });

    // Store the access token - use different storage strategy for personal vs business accounts
    let tokenKey;
    
    if (isPersonalAccount) {
      // For personal accounts, store under user ID
      tokenKey = `FacebookTokens/${userId}/token.json`;
    } else {
      // For business pages, store under page ID
      tokenKey = `FacebookTokens/${pageId}/token.json`;
    }

    const tokenData = {
      access_token: pageAccessToken, // Store the page access token
      user_access_token: userAccessToken, // Also store user token for future page token refreshes
      page_id: pageId,
      page_name: pageName,
      user_id: userId,
      user_name: userName,
      is_personal_account: isPersonalAccount,
      page_detection_method: pageDetectionMethod,
      timestamp: new Date().toISOString()
    };

    const putCommand = new PutObjectCommand({
      Bucket: 'tasks',
      Key: tokenKey,
      Body: JSON.stringify(tokenData, null, 2),
      ContentType: 'application/json',
    });

    await s3Client.send(putCommand);

    console.log(`[${new Date().toISOString()}] Facebook token stored successfully for page ${pageId}`);

    // Also store Facebook connection for the state userId (for easier lookup)
    if (state) {
      try {
        const connectionKey = `FacebookConnection/${state}/connection.json`;
        const connectionData = {
          uid: state,
          facebook_user_id: userId,
          facebook_page_id: pageId,
          username: pageName,
          access_token: pageAccessToken, // Store page token in connection
          user_access_token: userAccessToken, // Also store user token
          is_personal_account: isPersonalAccount,
          page_detection_method: pageDetectionMethod,
          lastUpdated: new Date().toISOString()
        };
        
        const connectionPutCommand = new PutObjectCommand({
          Bucket: 'tasks',
          Key: connectionKey,
          Body: JSON.stringify(connectionData, null, 2),
          ContentType: 'application/json',
        });
        
        await s3Client.send(connectionPutCommand);
        console.log(`[${new Date().toISOString()}] Facebook connection updated with real token for user ${state}`);
      } catch (connectionError) {
        console.error(`[${new Date().toISOString()}] Error storing Facebook connection:`, connectionError.message);
      }
    }

    // Send success response with appropriate message
    const accountType = isPersonalAccount ? 'Personal Account' : 'Business Page';
    const limitations = isPersonalAccount ? 
      `<div style="background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; margin: 15px 0; border-radius: 5px;">
        <h3 style="color: #856404; margin-top: 0;">⚠️ Personal Account Limitations</h3>
        <p style="color: #856404; margin-bottom: 10px;"><strong>Important:</strong> Personal Facebook accounts have very limited API access due to Facebook's privacy policies.</p>
        <ul style="color: #856404; margin-bottom: 10px;">
          <li>❌ No webhook support for DMs and comments</li>
          <li>❌ Limited automated posting capabilities</li>
          <li>❌ No insights or analytics data</li>
          <li>❌ Restricted API access for messaging</li>
        </ul>
        <p style="color: #856404; margin-bottom: 0;"><strong>Recommendation:</strong> For full functionality, consider converting to a Facebook Business Page or connecting a Facebook Business account.</p>
      </div>` : 
      `<div style="background-color: #d4edda; border: 1px solid #c3e6cb; padding: 15px; margin: 15px 0; border-radius: 5px;">
        <h3 style="color: #155724; margin-top: 0;">✅ Business Page Connected</h3>
        <p style="color: #155724; margin-bottom: 0;">Your Facebook Business Page is fully connected and ready for webhook events and automated features.</p>
      </div>`;

    res.send(`
      <html>
        <head>
          <style>
            body { font-family: Arial, sans-serif; margin: 40px; background-color: #f8f9fa; }
            .container { max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
            h2 { color: #2c3e50; text-align: center; margin-bottom: 30px; }
            .info { background-color: #e3f2fd; border: 1px solid #bbdefb; padding: 15px; margin: 15px 0; border-radius: 5px; }
            .info p { margin: 5px 0; color: #1565c0; }
            .button { background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 10px 5px; }
            .button:hover { background-color: #0056b3; }
          </style>
        </head>
        <body>
          <div class="container">
            <h2>Facebook Connected Successfully!</h2>
            
            <div class="info">
              <p><strong>Account Type:</strong> ${accountType}</p>
              <p><strong>Name:</strong> ${pageName}</p>
              <p><strong>ID:</strong> ${pageId}</p>
            </div>
            
            ${limitations}
            
            <div style="text-align: center; margin-top: 30px;">
              <button class="button" onclick="window.close()">Close Window</button>
            </div>
          </div>
          
          <script>
            window.opener.postMessage({ 
              type: 'FACEBOOK_CONNECTED', 
              facebookId: '${pageId}', 
              username: '${pageName}',
              isPersonalAccount: ${isPersonalAccount}
            }, '*');
          </script>
        </body>
      </html>
    `);
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Facebook OAuth callback error:`, error.response?.data || error.message);
    res.status(500).send('Error connecting Facebook account');
  }
});


// Webhook Verification
router.get(['/webhook/instagram', '/api/webhook/instagram'], (req, res) => {
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  if (mode === 'subscribe' && token === VERIFY_TOKEN) {
    console.log(`[${new Date().toISOString()}] WEBHOOK_VERIFIED for Instagram`);
    res.status(200).send(challenge);
  } else {
    console.log(`[${new Date().toISOString()}] WEBHOOK_VERIFICATION_FAILED: Invalid token or mode`);
    res.sendStatus(403);
  }
});

// Fixed Instagram Webhook POST Handler
router.post(['/instagram/callback', '/api/instagram/callback'], async (req, res) => {
  const body = req.body;

  if (body.object !== 'instagram') {
    console.log(`[${new Date().toISOString()}] Invalid payload received at callback, not Instagram object`);
    return res.sendStatus(404);
  }

  console.log(`[${new Date().toISOString()}] WEBHOOK ➜ Instagram payload received at callback: ${JSON.stringify(body)}`);

  try {
    for (const entry of body.entry) {
      const webhookGraphId = entry.id; // This is the Graph ID from the webhook
      console.log(`[${new Date().toISOString()}] Processing entry for Webhook Graph ID: ${webhookGraphId}`);

      // Find the user's actual token data based on webhook Graph ID
      let matchedToken = null;
      try {
        const listCommand = new ListObjectsV2Command({
          Bucket: 'tasks',
          Prefix: `InstagramTokens/`,
        });
        const { Contents } = await s3Client.send(listCommand);
        
        if (Contents) {
          console.log(`[${new Date().toISOString()}] Available tokens for webhook lookup:`);
          for (const obj of Contents) {
            if (obj.Key.endsWith('/token.json')) {
              const getCommand = new GetObjectCommand({
                Bucket: 'tasks',
                Key: obj.Key,
              });
              const data = await s3Client.send(getCommand);
              const json = await data.Body.transformToString();
              const token = JSON.parse(json);
              
              console.log(`[${new Date().toISOString()}] Token: graph_id=${token.instagram_graph_id}, user_id=${token.instagram_user_id}, username=${token.username}`);
              
              // FIXED: Match webhook Graph ID to instagram_user_id instead of instagram_graph_id
              // The webhook Graph ID often corresponds to the user_id, not the graph_id
              if (token.instagram_user_id === webhookGraphId || token.instagram_graph_id === webhookGraphId) {
                matchedToken = token;
                console.log(`[${new Date().toISOString()}] Found matching token for webhook ID ${webhookGraphId}: username=${token.username}, userUserId=${token.instagram_user_id}`);
                break;
              }
            }
          }
          
          if (!matchedToken) {
            console.log(`[${new Date().toISOString()}] No matching token found for webhook ID ${webhookGraphId}`);
          }
        }
      } catch (err) {
        console.error(`[${new Date().toISOString()}] Error finding token for webhook ID ${webhookGraphId}:`, err.message);
      }

      // Handle Direct Messages
      if (Array.isArray(entry.messaging)) {
        for (const msg of entry.messaging) {
          if (!msg.message?.text || msg.message.is_echo) {
            console.log(`[${new Date().toISOString()}] Skipping non-text or echo message: ${JSON.stringify(msg.message)}`);
            continue;
          }

          const eventData = {
            type: 'message',
            instagram_user_id: matchedToken ? matchedToken.instagram_user_id : webhookGraphId,
            sender_id: msg.sender.id,
            message_id: msg.message.mid,
            text: msg.message.text,
            timestamp: msg.timestamp,
            received_at: new Date().toISOString(),
            username: matchedToken ? matchedToken.username : 'unknown',
            status: 'pending'
          };

          // ALWAYS store with USER ID (not graph ID)
          const storeUserId = matchedToken ? matchedToken.instagram_user_id : webhookGraphId;
          if (!storeUserId) {
            console.log(`[${new Date().toISOString()}] Skipping DM storage - no user ID found for webhook ID ${webhookGraphId}`);
            continue;
          }
          
          console.log(`[${new Date().toISOString()}] Storing DM event with USER ID: ${storeUserId}`);
          
          const userKey = `InstagramEvents/${storeUserId}/${eventData.message_id}.json`;
          await s3Client.send(new PutObjectCommand({
            Bucket: 'tasks',
            Key: userKey,
            Body: JSON.stringify(eventData, null, 2),
            ContentType: 'application/json'
          }));
          
          console.log(`[${new Date().toISOString()}] Stored DM at ${userKey}`);

          // Broadcast update
          broadcastUpdate(storeUserId, { 
            event: 'message', 
            data: eventData,
            timestamp: Date.now() 
          });
          
          // Clear cache
          cache.delete(`InstagramEvents/${storeUserId}`);
        }
      }

      // Handle Comments (similar fix)
      if (Array.isArray(entry.changes)) {
        for (const change of entry.changes) {
          if (change.field !== 'comments' || !change.value?.text) {
            console.log(`[${new Date().toISOString()}] Skipping non-comment change: ${JSON.stringify(change)}`);
            continue;
          }

          const eventData = {
            type: 'comment',
            instagram_user_id: matchedToken ? matchedToken.instagram_user_id : webhookGraphId,
            comment_id: change.value.id,
            text: change.value.text,
            post_id: change.value.media.id,
            timestamp: change.value.timestamp || Date.now(),
            received_at: new Date().toISOString(),
            username: matchedToken ? matchedToken.username : 'unknown',
            status: 'pending'
          };

          // ALWAYS store with USER ID (not graph ID)
          const storeUserId = matchedToken ? matchedToken.instagram_user_id : webhookGraphId;
          if (!storeUserId) {
            console.log(`[${new Date().toISOString()}] Skipping comment storage - no user ID found for webhook ID ${webhookGraphId}`);
            continue;
          }
          
          console.log(`[${new Date().toISOString()}] Storing comment event with USER ID: ${storeUserId}`);
          
          const userKey = `InstagramEvents/${storeUserId}/comment_${eventData.comment_id}.json`;
          await s3Client.send(new PutObjectCommand({
            Bucket: 'tasks',
            Key: userKey,
            Body: JSON.stringify(eventData, null, 2),
            ContentType: 'application/json'
          }));
          
          console.log(`[${new Date().toISOString()}] Stored comment at ${userKey}`);

          // Broadcast update
          broadcastUpdate(storeUserId, { 
            event: 'comment', 
            data: eventData,
            timestamp: Date.now() 
          });
          
          // Clear cache
          cache.delete(`InstagramEvents/${storeUserId}`);
        }
      }
    }

    res.sendStatus(200);
  } catch (err) {
    console.error(`[${new Date().toISOString()}] Error processing webhook at callback:`, err);
    res.sendStatus(500);
  }
});

// Send DM Reply
router.post(['/send-dm-reply/:userId', '/api/send-dm-reply/:userId'], async (req, res) => {
  // Set CORS headers explicitly for this endpoint
  setCorsHeaders(res, req.headers.origin || '*');
  
  // Handle OPTIONS preflight requests
  if (req.method === 'OPTIONS') {
    return res.status(204).end();
  }
  
  const { userId } = req.params;
  const { sender_id, text, message_id, platform = 'instagram' } = req.body;

  if (!sender_id || !text || !message_id) {
    console.log(`[${new Date().toISOString()}] Missing required fields for DM reply`);
    return res.status(400).json({error: 'Missing sender_id, text, or message_id'});
  }

  console.log(`[${new Date().toISOString()}] Processing ${platform} DM reply for user ${userId}`);

  try {
    if (platform === 'twitter') {
      // Handle Twitter DM reply
      try {
        const result = await sendTwitterDMReply(userId, sender_id, text, message_id);
        
        // Update message status in Twitter events
        const messageKey = `TwitterEvents/${userId}/${message_id}.json`;
        try {
          const getCommand = new GetObjectCommand({
            Bucket: 'tasks',
            Key: messageKey,
          });
          const data = await s3Client.send(getCommand);
          const messageData = JSON.parse(await data.Body.transformToString());
          messageData.status = 'replied';
          messageData.updated_at = new Date().toISOString();

          await s3Client.send(new PutObjectCommand({
            Bucket: 'tasks',
            Key: messageKey,
            Body: JSON.stringify(messageData, null, 2),
            ContentType: 'application/json',
          }));
          
          // Invalidate cache
          cache.delete(`TwitterEvents/${userId}`);
          
          // Broadcast status update
          const statusUpdate = {
            type: 'message_status',
            message_id,
            status: 'replied',
            updated_at: messageData.updated_at,
            timestamp: Date.now(),
            platform: 'twitter'
          };
          
          broadcastUpdate(userId, { event: 'status_update', data: statusUpdate });
        } catch (error) {
          console.error(`[${new Date().toISOString()}] Error updating Twitter message status:`, error);
        }
        
        return res.json({ success: true, message_id: result.message_id });
      } catch (error) {
        console.error(`[${new Date().toISOString()}] Error sending Twitter DM reply:`, error.response?.data || error.message);
        if (error.message && error.message.includes('access token')) {
          return res.status(404).json({ error: 'No access token found for this Twitter account' });
        }
        return res.status(500).json({ error: 'Error sending Twitter DM reply', details: error.message });
      }
    }
    
    if (platform === 'facebook') {
      // Handle Facebook DM reply
      try {
        const result = await sendFacebookDMReply(userId, sender_id, text, message_id);
        
        // Update message status in Facebook events
        const messageKey = `FacebookEvents/${userId}/${message_id}.json`;
        try {
          const getCommand = new GetObjectCommand({
            Bucket: 'tasks',
            Key: messageKey,
          });
          const data = await s3Client.send(getCommand);
          const messageData = JSON.parse(await data.Body.transformToString());
          messageData.status = 'replied';
          messageData.updated_at = new Date().toISOString();

          await s3Client.send(new PutObjectCommand({
            Bucket: 'tasks',
            Key: messageKey,
            Body: JSON.stringify(messageData, null, 2),
            ContentType: 'application/json',
          }));
          
          // Invalidate cache
          cache.delete(`FacebookEvents/${userId}`);
          
          // Broadcast status update
          const statusUpdate = {
            type: 'message_status',
            message_id,
            status: 'replied',
            updated_at: messageData.updated_at,
            timestamp: Date.now(),
            platform: 'facebook'
          };
          
          broadcastUpdate(userId, { event: 'status_update', data: statusUpdate });
        } catch (error) {
          console.error(`[${new Date().toISOString()}] Error updating Facebook message status:`, error);
        }
        
        return res.json({ success: true, message_id: result.message_id });
      } catch (error) {
        console.error(`[${new Date().toISOString()}] Error sending Facebook DM reply:`, error.response?.data || error.message);
        if (error.message && error.message.includes('token')) {
          return res.status(404).json({ error: 'No access token found for this Facebook account' });
        }
        return res.status(500).json({ error: 'Error sending Facebook DM reply', details: error.message });
      }
    }
    
    // Handle Instagram DM reply (existing logic)
    // Find token data
    const listCommand = new ListObjectsV2Command({
      Bucket: 'tasks',
      Prefix: `InstagramTokens/`,
    });
    const { Contents } = await s3Client.send(listCommand);

    let tokenData = null;
    let username = null;
    if (Contents) {
      for (const obj of Contents) {
        if (obj.Key.endsWith('/token.json')) {
          const getCommand = new GetObjectCommand({
            Bucket: 'tasks',
            Key: obj.Key,
          });
          const data = await s3Client.send(getCommand);
          const json = await data.Body.transformToString();
          const token = JSON.parse(json);
          if (token.instagram_user_id === userId) {
            tokenData = token;
            username = token.username;
            break;
          }
        }
      }
    }

    if (!tokenData) {
      console.log(`[${new Date().toISOString()}] No token found for instagram_user_id ${userId}`);
      return res.status(404).json({error: 'No access token found for this Instagram account'});
    }

    const access_token = tokenData.access_token;
    const instagram_graph_id = tokenData.instagram_graph_id;

    // Validate sender_id format - this might need adjustment based on your specific ID format
    if (!/^[0-9]+$/.test(sender_id)) {
      console.log(`[${new Date().toISOString()}] Invalid sender_id format: ${sender_id}`);
      return res.status(400).json({error: 'Invalid sender_id format'});
    }

    try {
      // Send the DM reply
      console.log(`[${new Date().toISOString()}] Attempting to send DM to sender_id: ${sender_id} with access token for ${instagram_graph_id}`);
      
      const response = await axios({
        method: 'post',
        url: `https://graph.instagram.com/v22.0/${instagram_graph_id}/messages`,
        headers: {
          Authorization: `Bearer ${access_token}`,
          'Content-Type': 'application/json',
        },
        data: {
          recipient: { id: sender_id },
          message: { text },
        },
      });

      console.log(`[${new Date().toISOString()}] DM reply sent to ${sender_id} for instagram_graph_id ${instagram_graph_id}`);
    } catch (dmError) {
      console.error(`[${new Date().toISOString()}] Error sending DM reply:`, dmError.response?.data || dmError.message);
      
      // Handle the specific "user not found" error
      if (dmError.response?.data?.error?.code === 100 && 
          dmError.response?.data?.error?.error_subcode === 2534014) {
            
        // Mark the message as "handled" in storage even though we couldn't send the reply
        console.log(`[${new Date().toISOString()}] User ${sender_id} not found. Marking message as handled.`);
        
        // Update original message status to "handled" instead of "replied"
        const messageKey = `InstagramEvents/${userId}/${message_id}.json`;
        try {
          const getCommand = new GetObjectCommand({
            Bucket: 'tasks',
            Key: messageKey,
          });
          const data = await s3Client.send(getCommand);
          const messageData = JSON.parse(await data.Body.transformToString());
          messageData.status = 'handled';
          messageData.error = 'User not found';
          messageData.updated_at = new Date().toISOString();

          await s3Client.send(new PutObjectCommand({
            Bucket: 'tasks',
            Key: messageKey,
            Body: JSON.stringify(messageData, null, 2),
            ContentType: 'application/json',
          }));
          console.log(`[${new Date().toISOString()}] Updated DM status to handled at ${messageKey}`);
          
          // Return a "success" response but with a warning
          return res.json({ 
            success: true, 
            warning: 'Message marked as handled but DM not sent: user not found',
            handled: true
          });
        } catch (updateError) {
          console.error(`[${new Date().toISOString()}] Error updating message status:`, updateError);
        }
        
        // Return specific error for this case
        return res.status(404).json({ 
          error: 'Instagram user not found', 
          code: 'USER_NOT_FOUND',
          details: dmError.response?.data?.error || 'The specified recipient could not be found on Instagram'
        });
      }
      
      // Re-throw for general error handling
      throw dmError;
    }

    // Update original message status
    const messageKey = `InstagramEvents/${userId}/${message_id}.json`;
    try {
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: messageKey,
      });
      const data = await s3Client.send(getCommand);
      const messageData = JSON.parse(await data.Body.transformToString());
      messageData.status = 'replied';
      messageData.updated_at = new Date().toISOString();

      await s3Client.send(new PutObjectCommand({
        Bucket: 'tasks',
        Key: messageKey,
        Body: JSON.stringify(messageData, null, 2),
        ContentType: 'application/json',
      }));
      console.log(`[${new Date().toISOString()}] Updated DM status to replied at ${messageKey}`);
      
      // Invalidate cache for this module
      cache.delete(`InstagramEvents/${userId}`);
      if (username) cache.delete(`InstagramEvents/${username}`);
      
      // Broadcast status update
      const statusUpdate = {
        type: 'message_status',
        message_id,
        status: 'replied',
        updated_at: messageData.updated_at,
        timestamp: Date.now()
      };
      
      broadcastUpdate(userId, { event: 'status_update', data: statusUpdate });
      if (username) broadcastUpdate(username, { event: 'status_update', data: statusUpdate });
      
    } catch (error) {
      console.error(`[${new Date().toISOString()}] Error updating DM status:`, error);
    }

    // Store reply
    const replyKey = `InstagramEvents/${userId}/reply_${message_id}_${Date.now()}.json`;
    const replyData = {
      type: 'reply',
      instagram_user_id: userId,
      instagram_graph_id: instagram_graph_id,
      recipient_id: sender_id,
      message_id: response?.data?.id || `reply_${Date.now()}`,
      text,
      timestamp: Date.now(),
      sent_at: new Date().toISOString(),
      status: 'sent'
    };
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: replyKey,
      Body: JSON.stringify(replyData, null, 2),
      ContentType: 'application/json',
    }));
    console.log(`[${new Date().toISOString()}] Reply stored in R2 at ${replyKey}`);

    res.json({ success: true, message_id: response?.data?.id });
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error sending DM reply:`, error.response?.data || error.message);
    res.status(500).json({ 
      error: 'Error sending DM reply',
      details: error.response?.data?.error || error.message 
    });
  }
});

// Send Comment Reply
router.post(['/send-comment-reply/:userId', '/api/send-comment-reply/:userId'], async (req, res) => {
  // Set CORS headers explicitly for this endpoint
  setCorsHeaders(res, req.headers.origin || '*');
  
  // Handle OPTIONS preflight requests
  if (req.method === 'OPTIONS') {
    return res.status(204).end();
  }
  
  const { userId } = req.params;
  const { comment_id, text, platform = 'instagram' } = req.body;

  if (!comment_id || !text) {
    console.log(`[${new Date().toISOString()}] Missing required fields for comment reply`);
    return res.status(400).json({error: 'Missing comment_id or text'});
  }

  console.log(`[${new Date().toISOString()}] Processing ${platform} comment reply for user ${userId}`);

  try {
    if (platform === 'twitter') {
      // Handle Twitter mention reply (comments = mentions on Twitter)
      try {
        const result = await sendTwitterMentionReply(userId, comment_id, text);
        
        // Update mention status in Twitter events
        const commentKey = `TwitterEvents/${userId}/comment_${comment_id}.json`;
        try {
          const getCommand = new GetObjectCommand({
            Bucket: 'tasks',
            Key: commentKey,
          });
          const data = await s3Client.send(getCommand);
          const commentData = JSON.parse(await data.Body.transformToString());
          commentData.status = 'replied';
          commentData.updated_at = new Date().toISOString();

          await s3Client.send(new PutObjectCommand({
            Bucket: 'tasks',
            Key: commentKey,
            Body: JSON.stringify(commentData, null, 2),
            ContentType: 'application/json',
          }));
          
          // Invalidate cache
          cache.delete(`TwitterEvents/${userId}`);
          
          // Broadcast status update
          const statusUpdate = {
            type: 'comment_status',
            comment_id,
            status: 'replied',
            updated_at: commentData.updated_at,
            timestamp: Date.now(),
            platform: 'twitter'
          };
          
          broadcastUpdate(userId, { event: 'status_update', data: statusUpdate });
        } catch (error) {
          console.error(`[${new Date().toISOString()}] Error updating Twitter mention status:`, error);
        }
        
        return res.json({ success: true, reply_id: result.tweet_id });
      } catch (error) {
        console.error(`[${new Date().toISOString()}] Error sending Twitter mention reply:`, error.response?.data || error.message);
        if (error.message && error.message.includes('access token')) {
          return res.status(404).json({ error: 'No access token found for this Twitter account' });
        }
        return res.status(500).json({ error: 'Error sending Twitter mention reply', details: error.message });
      }
    }
    
    if (platform === 'facebook') {
      // Handle Facebook comment reply
      try {
        const result = await sendFacebookCommentReply(userId, comment_id, text);
        
        // Update comment status in Facebook events
        const commentKey = `FacebookEvents/${userId}/comment_${comment_id}.json`;
        try {
          const getCommand = new GetObjectCommand({
            Bucket: 'tasks',
            Key: commentKey,
          });
          const data = await s3Client.send(getCommand);
          const commentData = JSON.parse(await data.Body.transformToString());
          commentData.status = 'replied';
          commentData.updated_at = new Date().toISOString();

          await s3Client.send(new PutObjectCommand({
            Bucket: 'tasks',
            Key: commentKey,
            Body: JSON.stringify(commentData, null, 2),
            ContentType: 'application/json',
          }));
          
          // Invalidate cache
          cache.delete(`FacebookEvents/${userId}`);
          
          // Broadcast status update
          const statusUpdate = {
            type: 'comment_status',
            comment_id,
            status: 'replied',
            updated_at: commentData.updated_at,
            timestamp: Date.now(),
            platform: 'facebook'
          };
          
          broadcastUpdate(userId, { event: 'status_update', data: statusUpdate });
        } catch (error) {
          console.error(`[${new Date().toISOString()}] Error updating Facebook comment status:`, error);
        }
        
        return res.json({ success: true, reply_id: result.comment_id });
      } catch (error) {
        console.error(`[${new Date().toISOString()}] Error sending Facebook comment reply:`, error.response?.data || error.message);
        if (error.message && error.message.includes('token')) {
          return res.status(404).json({ error: 'No access token found for this Facebook account' });
        }
        return res.status(500).json({ error: 'Error sending Facebook comment reply', details: error.message });
      }
    }
    
    // Handle Instagram comment reply (existing logic)
    // Find token data
    const listCommand = new ListObjectsV2Command({
      Bucket: 'tasks',
      Prefix: `InstagramTokens/`,
    });
    const { Contents } = await s3Client.send(listCommand);

    let tokenData = null;
    let username = null;
    if (Contents) {
      for (const obj of Contents) {
        if (obj.Key.endsWith('/token.json')) {
          const getCommand = new GetObjectCommand({
            Bucket: 'tasks',
            Key: obj.Key,
          });
          const data = await s3Client.send(getCommand);
          const json = await data.Body.transformToString();
          const token = JSON.parse(json);
          if (token.instagram_user_id === userId) {
            tokenData = token;
            username = token.username;
            break;
          }
        }
      }
    }

    if (!tokenData) {
      console.log(`[${new Date().toISOString()}] No token found for instagram_user_id ${userId}`);
      return res.status(404).send('No access token found for this Instagram account');
    }

    const access_token = tokenData.access_token;

    // Send the comment reply
    const response = await axios({
      method: 'post',
      url: `https://graph.instagram.com/v22.0/${comment_id}/replies`,
      headers: {
        Authorization: `Bearer ${access_token}`,
        'Content-Type': 'application/json',
      },
      data: {
        message: text
      },
    });

    console.log(`[${new Date().toISOString()}] Comment reply sent for comment_id ${comment_id}`);

    // Update original comment status
    const commentKey = `InstagramEvents/${userId}/comment_${comment_id}.json`;
    try {
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: commentKey,
      });
      const data = await s3Client.send(getCommand);
      const commentData = JSON.parse(await data.Body.transformToString());
      commentData.status = 'replied';
      commentData.updated_at = new Date().toISOString();

      await s3Client.send(new PutObjectCommand({
        Bucket: 'tasks',
        Key: commentKey,
        Body: JSON.stringify(commentData, null, 2),
        ContentType: 'application/json',
      }));
      console.log(`[${new Date().toISOString()}] Updated comment status to replied at ${commentKey}`);
      
      // Invalidate cache
      cache.delete(`InstagramEvents/${userId}`);
      if (username) cache.delete(`InstagramEvents/${username}`);
      
      // Broadcast status update
      const statusUpdate = {
        type: 'comment_status',
        comment_id,
        status: 'replied',
        updated_at: commentData.updated_at,
        timestamp: Date.now()
      };
      
      broadcastUpdate(userId, { event: 'status_update', data: statusUpdate });
      if (username) broadcastUpdate(username, { event: 'status_update', data: statusUpdate });
      
    } catch (error) {
      console.error(`[${new Date().toISOString()}] Error updating comment status:`, error);
    }

    // Store reply
    const replyKey = `InstagramEvents/${userId}/comment_reply_${comment_id}_${Date.now()}.json`;
    const replyData = {
      type: 'comment_reply',
      instagram_user_id: userId,
      comment_id,
      reply_id: response.data.id || `reply_${Date.now()}`,
      text,
      timestamp: Date.now(),
      sent_at: new Date().toISOString(),
      status: 'sent'
    };
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: replyKey,
      Body: JSON.stringify(replyData, null, 2),
      ContentType: 'application/json',
    }));
    console.log(`[${new Date().toISOString()}] Comment reply stored in R2 at ${replyKey}`);

    res.json({ success: true, reply_id: response.data.id });
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error sending comment reply:`, error.response?.data || error.message);
    res.status(500).send('Error sending comment reply');
  }
});

// Ignore Notification
router.post(['/ignore-notification/:userId', '/api/ignore-notification/:userId'], async (req, res) => {
  const { userId } = req.params;
  const { message_id, comment_id, platform = 'instagram' } = req.body;

  console.log(`[${new Date().toISOString()}] [IGNORE] Ignore request received:`, {
    userId,
    message_id,
    comment_id,
    platform
  });

  if (!message_id && !comment_id) {
    console.log(`[${new Date().toISOString()}] Missing message_id or comment_id for ignore action`);
    return res.status(400).json({ error: 'Missing message_id or comment_id' });
  }

  try {
    // Find username if available
    let username = null;
    try {
      const tokenPrefix = platform === 'twitter' ? 'TwitterTokens/' : 
                         platform === 'facebook' ? 'FacebookTokens/' : 
                         'InstagramTokens/';
      const listCommand = new ListObjectsV2Command({
        Bucket: 'tasks',
        Prefix: tokenPrefix,
      });
      const { Contents } = await s3Client.send(listCommand);
      if (Contents) {
        for (const obj of Contents) {
          if (obj.Key.endsWith('/token.json')) {
            const getCommand = new GetObjectCommand({
              Bucket: 'tasks',
              Key: obj.Key,
            });
            const data = await s3Client.send(getCommand);
            const json = await data.Body.transformToString();
            const token = JSON.parse(json);
            const userIdField = platform === 'twitter' ? 'twitter_user_id' : 
                               platform === 'facebook' ? 'facebook_user_id' :
                               'instagram_user_id';
            if (token[userIdField] === userId) {
              username = token.username;
              break;
            }
          }
        }
      }
    } catch (err) {
      console.error(`[${new Date().toISOString()}] Error finding username for ${platform} user ID ${userId}:`, err.message);
    }
    
    const eventPrefix = platform === 'twitter' ? 'TwitterEvents' : 
                       platform === 'facebook' ? 'FacebookEvents' :
                       'InstagramEvents';
    const fileKey = message_id 
      ? `${eventPrefix}/${userId}/${message_id}.json`
      : `${eventPrefix}/${userId}/comment_${comment_id}.json`;

    console.log(`[${new Date().toISOString()}] [IGNORE] Will store ignored status at: ${fileKey}`);

    let updatedItem;
    try {
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: fileKey,
      });
      const data = await s3Client.send(getCommand);
      const notifData = JSON.parse(await data.Body.transformToString());
      notifData.status = 'ignored';
      notifData.updated_at = new Date().toISOString();
      updatedItem = notifData;

      await s3Client.send(new PutObjectCommand({
        Bucket: 'tasks',
        Key: fileKey,
        Body: JSON.stringify(notifData, null, 2),
        ContentType: 'application/json',
      }));
      console.log(`[${new Date().toISOString()}] Updated ${platform} notification status to ignored at ${fileKey}`);
      
      // Comprehensive cache invalidation for ignore functionality
      cache.delete(`${eventPrefix}/${userId}`);
      cache.delete(`events-list/${userId}`);
      cache.delete(`events-list/${userId}?platform=${platform}`);
      if (username) {
        cache.delete(`${eventPrefix}/${username}`);
        cache.delete(`events-list/${username}`);
      }
      
      // Clear data module caches to force refresh
      const dataModuleCacheKey = `data_${username || userId}_events_${platform}`;
      cache.delete(dataModuleCacheKey);
      
      // Broadcast status update
      const statusUpdate = {
        type: message_id ? 'message_status' : 'comment_status',
        [message_id ? 'message_id' : 'comment_id']: message_id || comment_id,
        status: 'ignored',
        updated_at: notifData.updated_at,
        timestamp: Date.now(),
        platform: platform
      };
      
      broadcastUpdate(userId, { event: 'status_update', data: statusUpdate });
      if (username) broadcastUpdate(username, { event: 'status_update', data: statusUpdate });
      
    } catch (error) {
      if (error.name === 'NoSuchKey') {
        console.log(`[${new Date().toISOString()}] ${platform} notification file not found at ${fileKey}, creating new ignored status file`);
        
        // Create a new ignored status file since the original doesn't exist
        const ignoredNotificationData = {
          message_id: message_id,
          comment_id: comment_id,
          status: 'ignored',
          platform: platform,
          user_id: userId,
          ignored_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };
        
        await s3Client.send(new PutObjectCommand({
          Bucket: 'tasks',
          Key: fileKey,
          Body: JSON.stringify(ignoredNotificationData, null, 2),
          ContentType: 'application/json',
        }));
        
        console.log(`[${new Date().toISOString()}] Created new ignored status file at ${fileKey}`);
        updatedItem = ignoredNotificationData;
        
        // Comprehensive cache invalidation for ignore functionality
        cache.delete(`${eventPrefix}/${userId}`);
        cache.delete(`events-list/${userId}`);
        cache.delete(`events-list/${userId}?platform=${platform}`);
        if (username) {
          cache.delete(`${eventPrefix}/${username}`);
          cache.delete(`events-list/${username}`);
        }
        
        // Clear data module caches to force refresh
        const dataModuleCacheKey = `data_${username || userId}_events_${platform}`;
        cache.delete(dataModuleCacheKey);
        
        // Broadcast status update
        const statusUpdate = {
          type: message_id ? 'message_status' : 'comment_status',
          [message_id ? 'message_id' : 'comment_id']: message_id || comment_id,
          status: 'ignored',
          updated_at: ignoredNotificationData.updated_at,
          timestamp: Date.now(),
          platform: platform
        };
        
        broadcastUpdate(userId, { event: 'status_update', data: statusUpdate });
        if (username) broadcastUpdate(username, { event: 'status_update', data: statusUpdate });
        
      } else {
        throw error;
      }
    }

    console.log(`[${new Date().toISOString()}] [IGNORE] Successfully ignored ${platform} notification:`, {
      userId,
      message_id,
      comment_id,
      fileKey,
      updated: !!updatedItem
    });

    res.json({ success: true, updated: !!updatedItem });
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error ignoring ${platform} notification:`, error.message || error);
    res.status(500).json({ error: `Failed to ignore ${platform} notification`, details: error.message || 'Unknown error' });
  }
});

// List Stored Events
router.get(['/events-list/:userId', '/api/events-list/:userId'], async (req, res) => {
  const { userId } = req.params;
  const platform = req.query.platform || 'instagram';
  const forceRefresh = req.query.forceRefresh === 'true';

  try {
    // Clear cache if force refresh is requested
    if (forceRefresh) {
      const eventPrefix = platform === 'twitter' ? 'TwitterEvents' : 
                         platform === 'facebook' ? 'FacebookEvents' :
                         'InstagramEvents';
      cache.delete(`${eventPrefix}/${userId}`);
      cache.delete(`events-list/${userId}`);
      cache.delete(`events-list/${userId}?platform=${platform}`);
      console.log(`[${new Date().toISOString()}] Force refreshing ${platform} notifications cache for ${userId}`);
    }

    let notifications = [];
    if (platform === 'instagram') {
      notifications = await fetchInstagramNotifications(userId);
    } else if (platform === 'twitter') {
      notifications = await fetchTwitterNotifications(userId);
    } else if (platform === 'facebook') {
      // For Facebook, pass forceRefresh flag to enable API fallback when R2 is empty
      notifications = await fetchFacebookNotifications(userId, forceRefresh);
    }

    res.json(notifications);
  } catch (error) {
    console.error(`Error fetching ${platform} notifications:`, error);
    res.status(500).json({ error: `Failed to fetch ${platform} notifications` });
  }
});

// Helper function to filter out handled/replied/ignored notifications
async function filterHandledNotifications(notifications, userId, platform) {
  console.log(`[${new Date().toISOString()}] [FILTER] Starting filter for ${platform} notifications:`, {
    userId,
    totalNotifications: notifications?.length || 0
  });

  if (!notifications || notifications.length === 0) {
    return notifications;
  }

  const eventPrefix = platform === 'twitter' ? 'TwitterEvents' : 
                     platform === 'facebook' ? 'FacebookEvents' :
                     'InstagramEvents';

  const filteredNotifications = [];

  // Always resolve to correct user_id for Facebook
  let resolvedUserId = userId;
  if (platform === 'facebook') {
    try {
      const tokenListCommand = new ListObjectsV2Command({
        Bucket: 'tasks',
        Prefix: `FacebookTokens/`,
      });
      const { Contents: tokenContents } = await s3Client.send(tokenListCommand);
      if (tokenContents) {
        for (const obj of tokenContents) {
          if (obj.Key.endsWith('/token.json')) {
            try {
              const getCommand = new GetObjectCommand({
                Bucket: 'tasks',
                Key: obj.Key,
              });
              const data = await s3Client.send(getCommand);
              const token = JSON.parse(await data.Body.transformToString());
              if (token.page_id === userId || token.user_id === userId) {
                resolvedUserId = token.user_id;
                break;
              }
            } catch {}
          }
        }
      }
    } catch {}
  }

  for (const notification of notifications) {
    const notificationId = notification.message_id || notification.comment_id;
    if (!notificationId) {
      filteredNotifications.push(notification);
      continue;
    }
    try {
      const fileKey = notification.message_id 
        ? `${eventPrefix}/${resolvedUserId}/${notification.message_id}.json`
        : `${eventPrefix}/${resolvedUserId}/comment_${notification.comment_id}.json`;
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: fileKey,
      });
      const data = await s3Client.send(getCommand);
      const storedNotification = JSON.parse(await data.Body.transformToString());
      if (storedNotification.status && 
          ['replied', 'ignored', 'ai_handled', 'handled', 'sent', 'scheduled', 'posted', 'published'].includes(storedNotification.status)) {
        continue;
      }
      filteredNotifications.push({
        ...notification,
        status: storedNotification.status || 'pending'
      });
    } catch (error) {
      if (error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
        filteredNotifications.push(notification);
      } else {
        filteredNotifications.push(notification);
      }
    }
  }
  return filteredNotifications;
}



async function fetchInstagramNotifications(userId) {
  try {
    console.log(`[${new Date().toISOString()}] [INSTAGRAM] Fetching notifications for userId: ${userId}`);
    
    // PRIORITY 1: Fetch from R2 bucket (where webhook events are stored)
    const dms = await fetchInstagramDMs(userId);
    const comments = await fetchInstagramComments(userId);
    
    // Combine and format notifications
    let notifications = [
      ...dms.map(dm => ({
        type: 'message',
        instagram_user_id: userId,
        sender_id: dm.sender_id,
        message_id: dm.id,
        text: dm.text,
        timestamp: new Date(dm.created_at).getTime(),
        received_at: dm.created_at,
        username: dm.sender_username,
        status: 'pending',
        platform: 'instagram'
      })),
      ...comments.map(comment => ({
        type: 'comment',
        instagram_user_id: userId,
        sender_id: comment.user_id,
        comment_id: comment.id,
        text: comment.text,
        post_id: comment.media_id,
        timestamp: new Date(comment.created_at).getTime(),
        received_at: comment.created_at,
        username: comment.username,
        status: 'pending',
        platform: 'instagram'
      }))
    ];

    console.log(`[${new Date().toISOString()}] [INSTAGRAM] R2 bucket notifications:`, {
      userId,
      dmsCount: dms.length,
      commentsCount: comments.length,
      totalCount: notifications.length
    });

    // Filter out handled/replied/ignored notifications
    notifications = await filterHandledNotifications(notifications, userId, 'instagram');

    console.log(`[${new Date().toISOString()}] [INSTAGRAM] Final filtered notifications:`, {
      userId,
      beforeFilter: notifications.length,
      afterFilter: notifications.length
    });

    return notifications;
  } catch (error) {
    console.error('Error fetching Instagram notifications:', error);
    throw error;
  }
}

async function fetchTwitterNotifications(userId) {
  try {
    console.log(`[${new Date().toISOString()}] [TWITTER] Fetching notifications for userId: ${userId}`);
    
    // PRIORITY 1: Fetch from R2 bucket (where webhook events are stored)
    const dms = await fetchTwitterDMs(userId);
    const mentions = await fetchTwitterMentions(userId);
    
    // Combine and format notifications
    let notifications = [
      ...dms.map(dm => ({
        type: 'message',
        twitter_user_id: userId,
        sender_id: dm.sender_id,
        message_id: dm.id,
        text: dm.text,
        timestamp: new Date(dm.created_at).getTime(),
        received_at: dm.created_at,
        username: dm.sender_username,
        status: 'pending',
        platform: 'twitter'
      })),
      ...mentions.map(mention => ({
        type: 'comment',
        twitter_user_id: userId,
        sender_id: mention.user_id,
        comment_id: mention.id,
        text: mention.text,
        timestamp: new Date(mention.created_at).getTime(),
        received_at: mention.created_at,
        username: mention.username,
        status: 'pending',
        platform: 'twitter'
      }))
    ];

    console.log(`[${new Date().toISOString()}] [TWITTER] R2 bucket notifications:`, {
      userId,
      dmsCount: dms.length,
      mentionsCount: mentions.length,
      totalCount: notifications.length
    });

    // Filter out handled/replied/ignored notifications
    notifications = await filterHandledNotifications(notifications, userId, 'twitter');

    console.log(`[${new Date().toISOString()}] [TWITTER] Final filtered notifications:`, {
      userId,
      beforeFilter: notifications.length,
      afterFilter: notifications.length
    });

    return notifications;
  } catch (error) {
    console.error('Error fetching Twitter notifications:', error);
    throw error;
  }
}

// Twitter notification helper functions (placeholder implementations)
async function fetchTwitterDMs(userId) {
  try {
    // TODO: Implement actual Twitter API calls
    // For now, return empty array to prevent crashes (reduced logging)
    return [];
  } catch (error) {
    console.error('Error fetching Twitter DMs:', error);
    return [];
  }
}

async function fetchTwitterMentions(userId) {
  try {
    // TODO: Implement actual Twitter API calls
    // For now, return empty array to prevent crashes (reduced logging)
    return [];
  } catch (error) {
    console.error('Error fetching Twitter mentions:', error);
    return [];
  }
}

async function sendTwitterDMReply(userId, senderId, text, messageId) {
  try {
    // TODO: Implement actual Twitter API calls
    // For now, just return success (reduced logging)
    return { success: true, message: 'Twitter DM reply sent (placeholder)' };
  } catch (error) {
    console.error('Error sending Twitter DM reply:', error);
    throw error;
  }
}

async function sendTwitterMentionReply(userId, commentId, text) {
  try {
    // TODO: Implement actual Twitter API calls
    // For now, just return success (reduced logging)
    return { success: true, message: 'Twitter mention reply sent (placeholder)' };
  } catch (error) {
    console.error('Error sending Twitter mention reply:', error);
    throw error;
  }
}

// Facebook notification helper functions
async function fetchFacebookNotifications(userId, forceRefresh = false) {
  console.log(`[${new Date().toISOString()}] [FACEBOOK] Fetching notifications for userId: ${userId}, forceRefresh: ${forceRefresh}`);
  
  try {
    // Get Facebook access token for validation
    const tokenData = await getFacebookTokenData(userId);
    if (!tokenData) {
      console.log(`[${new Date().toISOString()}] [FACEBOOK] No token data found for userId: ${userId}`);
      return [];
    }

    console.log(`[${new Date().toISOString()}] [FACEBOOK] Token data found:`, {
      userId,
      page_id: tokenData.page_id,
      user_id: tokenData.user_id,
      hasAccessToken: !!tokenData.access_token
    });

    const notifications = [];
    
    // PRIORITY 1: Fetch from R2 bucket (where webhook events are stored)
    const r2Dms = await fetchFacebookDMsFromR2(userId);
    const r2Comments = await fetchFacebookCommentsFromR2(userId);
    
    notifications.push(...r2Dms);
    notifications.push(...r2Comments);
    
    console.log(`[${new Date().toISOString()}] [FACEBOOK] R2 bucket notifications:`, {
      userId,
      dmsCount: r2Dms.length,
      commentsCount: r2Comments.length,
      totalCount: notifications.length
    });
    
    // PRIORITY 2: Only fetch from API if R2 is empty AND force refresh is requested
    // This avoids API permission issues and reduces API calls
    if (notifications.length === 0 && forceRefresh) {
      console.log(`[${new Date().toISOString()}] [FACEBOOK] No R2 notifications found and force refresh requested, attempting API fallback for ${userId}`);
      
      try {
        const apiDms = await fetchFacebookDMsFromAPI(userId, tokenData);
        const apiComments = await fetchFacebookCommentsFromAPI(userId, tokenData);
        
        notifications.push(...apiDms);
        notifications.push(...apiComments);
        
        console.log(`[${new Date().toISOString()}] [FACEBOOK] API fallback notifications:`, {
          userId,
          dmsCount: apiDms.length,
          commentsCount: apiComments.length,
          totalCount: notifications.length
        });
      } catch (apiError) {
        console.log(`[${new Date().toISOString()}] [FACEBOOK] API fallback failed for ${userId}:`, apiError.message);
        // Continue with R2 data only
      }
    } else if (notifications.length === 0 && !forceRefresh) {
      console.log(`[${new Date().toISOString()}] [FACEBOOK] No R2 notifications found for ${userId}, but force refresh not requested - skipping API fallback`);
    }
    
    console.log(`[${new Date().toISOString()}] [FACEBOOK] Raw notifications before filtering:`, {
      userId,
      totalCount: notifications.length
    });
    
    // Filter out handled/replied/ignored notifications
    const filteredNotifications = await filterHandledNotifications(notifications, userId, 'facebook');
    
    console.log(`[${new Date().toISOString()}] [FACEBOOK] Final filtered notifications:`, {
      userId,
      beforeFilter: notifications.length,
      afterFilter: filteredNotifications.length
    });
    
    return filteredNotifications.sort((a, b) => b.timestamp - a.timestamp);
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error fetching Facebook notifications for ${userId}:`, error.message);
    return [];
  }
}

// Fetch Facebook DMs from R2 bucket (where webhook events are stored)
async function fetchFacebookDMsFromR2(userId) {
  try {
    console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Fetching DMs from R2 for userId: ${userId}`);
    
    // Enhanced user ID resolution for Facebook events
    let resolvedUserId = userId;
    let listCommand = new ListObjectsV2Command({
      Bucket: 'tasks',
      Prefix: `FacebookEvents/${userId}/`,
    });
    let { Contents } = await s3Client.send(listCommand);
    
    if (!Contents || Contents.length === 0) {
      // Strategy 1: Try to resolve user_id from Facebook tokens
      try {
        const tokenListCommand = new ListObjectsV2Command({
          Bucket: 'tasks',
          Prefix: `FacebookTokens/`,
        });
        const { Contents: tokenContents } = await s3Client.send(tokenListCommand);
        if (tokenContents) {
          for (const obj of tokenContents) {
            if (obj.Key.endsWith('/token.json')) {
              try {
                const getCommand = new GetObjectCommand({
                  Bucket: 'tasks',
                  Key: obj.Key,
                });
                const data = await s3Client.send(getCommand);
                const token = JSON.parse(await data.Body.transformToString());
                
                // CRITICAL FIX: The userId is the Firebase user ID, and events are stored under that ID
                // We need to check if this token belongs to the Firebase user ID
                const firebaseUserId = obj.Key.split('/')[1]; // Extract Firebase user ID from token key
                if (firebaseUserId === userId) {
                  // Events are stored under the Firebase user ID, so use that
                  resolvedUserId = firebaseUserId;
                  console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Found token for Firebase user ${userId}, using Firebase user ID for event lookup`);
                  listCommand = new ListObjectsV2Command({
                    Bucket: 'tasks',
                    Prefix: `FacebookEvents/${resolvedUserId}/`,
                  });
                  const result = await s3Client.send(listCommand);
                  Contents = result.Contents;
                  break;
                }
                
                // CRITICAL FIX: Also check if the Facebook user_id matches the userId (for backward compatibility)
                if (token.user_id === userId) {
                  // Events might be stored under the Facebook user ID
                  resolvedUserId = token.user_id;
                  console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Found token for Facebook user ${userId}, using Facebook user ID for event lookup`);
                  listCommand = new ListObjectsV2Command({
                    Bucket: 'tasks',
                    Prefix: `FacebookEvents/${resolvedUserId}/`,
                  });
                  const result = await s3Client.send(listCommand);
                  Contents = result.Contents;
                  break;
                }
              } catch (tokenError) {
                console.error(`[${new Date().toISOString()}] Error reading token file ${obj.Key}:`, tokenError.message);
                continue;
              }
            }
          }
        }
      } catch (tokenSearchError) {
        console.error(`[${new Date().toISOString()}] Error searching Facebook tokens:`, tokenSearchError.message);
      }
      
      // Strategy 2: Try to resolve from Facebook connections
      if (!Contents || Contents.length === 0) {
        try {
          const connectionListCommand = new ListObjectsV2Command({
            Bucket: 'tasks',
            Prefix: `FacebookConnection/`,
          });
          const { Contents: connectionContents } = await s3Client.send(connectionListCommand);
          
          if (connectionContents) {
            for (const obj of connectionContents) {
              if (obj.Key.endsWith('/connection.json')) {
                try {
                  const getCommand = new GetObjectCommand({
                    Bucket: 'tasks',
                    Key: obj.Key,
                  });
                  const data = await s3Client.send(getCommand);
                  const connection = JSON.parse(await data.Body.transformToString());
                  
                  // CRITICAL FIX: The userId is the Firebase user ID, and events are stored under that ID
                  // We need to check if this connection belongs to the Firebase user ID
                  const firebaseUserId = obj.Key.split('/')[1]; // Extract Firebase user ID from connection key
                  if (firebaseUserId === userId) {
                    // Events are stored under the Firebase user ID, so use that
                    resolvedUserId = firebaseUserId;
                    console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Found connection for Firebase user ${userId}, using Firebase user ID for event lookup`);
                    listCommand = new ListObjectsV2Command({
                      Bucket: 'tasks',
                      Prefix: `FacebookEvents/${resolvedUserId}/`,
                    });
                    const result = await s3Client.send(listCommand);
                    Contents = result.Contents;
                    break;
                  }
                  
                  // CRITICAL FIX: Also check if the Facebook user_id matches the userId (for backward compatibility)
                  if (connection.facebook_user_id === userId) {
                    // Events might be stored under the Facebook user ID
                    resolvedUserId = connection.facebook_user_id;
                    console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Found connection for Facebook user ${userId}, using Facebook user ID for event lookup`);
                    listCommand = new ListObjectsV2Command({
                      Bucket: 'tasks',
                      Prefix: `FacebookEvents/${resolvedUserId}/`,
                    });
                    const result = await s3Client.send(listCommand);
                    Contents = result.Contents;
                    break;
                  }
                } catch (connectionError) {
                  console.error(`[${new Date().toISOString()}] Error reading connection file ${obj.Key}:`, connectionError.message);
                  continue;
                }
              }
            }
          }
        } catch (connectionSearchError) {
          console.error(`[${new Date().toISOString()}] Error searching Facebook connections:`, connectionSearchError.message);
        }
      }
    }
    const dms = [];
    if (Contents && Contents.length > 0) {
      for (const obj of Contents) {
        if (obj.Key.endsWith('.json') && !obj.Key.includes('reply_') && !obj.Key.includes('comment_')) {
          try {
            const getCommand = new GetObjectCommand({
              Bucket: 'tasks',
              Key: obj.Key,
            });
            const data = await s3Client.send(getCommand);
            const eventData = JSON.parse(await data.Body.transformToString());
            if (eventData.type === 'message') {
              dms.push({
                type: 'message',
                facebook_user_id: resolvedUserId,
                facebook_page_id: eventData.facebook_page_id,
                sender_id: eventData.sender_id,
                message_id: eventData.message_id,
                text: eventData.text,
                timestamp: new Date(eventData.received_at).getTime(),
                received_at: eventData.received_at,
                username: eventData.username || 'Unknown',
                status: eventData.status || 'pending',
                platform: 'facebook'
              });
            }
          } catch {}
        }
      }
    }
    console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Found ${dms.length} DMs in R2 for user ${resolvedUserId}`);
    return dms;
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error fetching Facebook DMs from R2 for ${userId}:`, error.message);
    return [];
  }
}

// Fetch Facebook comments from R2 bucket (where webhook events are stored)
async function fetchFacebookCommentsFromR2(userId) {
  try {
    console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Fetching comments from R2 for userId: ${userId}`);
    // Enhanced user ID resolution for Facebook events
    let resolvedUserId = userId;
    let listCommand = new ListObjectsV2Command({
      Bucket: 'tasks',
      Prefix: `FacebookEvents/${userId}/`,
    });
    let { Contents } = await s3Client.send(listCommand);
    
    if (!Contents || Contents.length === 0) {
      // Strategy 1: Try to resolve user_id from Facebook tokens
      try {
        const tokenListCommand = new ListObjectsV2Command({
          Bucket: 'tasks',
          Prefix: `FacebookTokens/`,
        });
        const { Contents: tokenContents } = await s3Client.send(tokenListCommand);
        if (tokenContents) {
          for (const obj of tokenContents) {
            if (obj.Key.endsWith('/token.json')) {
              try {
                const getCommand = new GetObjectCommand({
                  Bucket: 'tasks',
                  Key: obj.Key,
                });
                const data = await s3Client.send(getCommand);
                const token = JSON.parse(await data.Body.transformToString());
                
                // CRITICAL FIX: The userId is the Firebase user ID, and events are stored under that ID
                // We need to check if this token belongs to the Firebase user ID
                const firebaseUserId = obj.Key.split('/')[1]; // Extract Firebase user ID from token key
                if (firebaseUserId === userId) {
                  // Events are stored under the Firebase user ID, so use that
                  resolvedUserId = firebaseUserId;
                  console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Found token for Firebase user ${userId}, using Firebase user ID for comment lookup`);
                  listCommand = new ListObjectsV2Command({
                    Bucket: 'tasks',
                    Prefix: `FacebookEvents/${resolvedUserId}/`,
                  });
                  const result = await s3Client.send(listCommand);
                  Contents = result.Contents;
                  break;
                }
                
                // CRITICAL FIX: Also check if the Facebook user_id matches the userId (for backward compatibility)
                if (token.user_id === userId) {
                  // Events might be stored under the Facebook user ID
                  resolvedUserId = token.user_id;
                  console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Found token for Facebook user ${userId}, using Facebook user ID for comment lookup`);
                  listCommand = new ListObjectsV2Command({
                    Bucket: 'tasks',
                    Prefix: `FacebookEvents/${resolvedUserId}/`,
                  });
                  const result = await s3Client.send(listCommand);
                  Contents = result.Contents;
                  break;
                }
              } catch (tokenError) {
                console.error(`[${new Date().toISOString()}] Error reading token file ${obj.Key}:`, tokenError.message);
                continue;
              }
            }
          }
        }
      } catch (tokenSearchError) {
        console.error(`[${new Date().toISOString()}] Error searching Facebook tokens for comments:`, tokenSearchError.message);
      }
      
      // Strategy 2: Try to resolve from Facebook connections
      if (!Contents || Contents.length === 0) {
        try {
          const connectionListCommand = new ListObjectsV2Command({
            Bucket: 'tasks',
            Prefix: `FacebookConnection/`,
          });
          const { Contents: connectionContents } = await s3Client.send(connectionListCommand);
          
          if (connectionContents) {
            for (const obj of connectionContents) {
              if (obj.Key.endsWith('/connection.json')) {
                try {
                  const getCommand = new GetObjectCommand({
                    Bucket: 'tasks',
                    Key: obj.Key,
                  });
                  const data = await s3Client.send(getCommand);
                  const connection = JSON.parse(await data.Body.transformToString());
                  
                  // CRITICAL FIX: The userId is the Firebase user ID, and events are stored under that ID
                  // We need to check if this connection belongs to the Firebase user ID
                  const firebaseUserId = obj.Key.split('/')[1]; // Extract Firebase user ID from connection key
                  if (firebaseUserId === userId) {
                    // Events are stored under the Firebase user ID, so use that
                    resolvedUserId = firebaseUserId;
                    console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Found connection for Firebase user ${userId}, using Firebase user ID for comment lookup`);
                    listCommand = new ListObjectsV2Command({
                      Bucket: 'tasks',
                      Prefix: `FacebookEvents/${resolvedUserId}/`,
                    });
                    const result = await s3Client.send(listCommand);
                    Contents = result.Contents;
                    break;
                  }
                  
                  // CRITICAL FIX: Also check if the Facebook user_id matches the userId (for backward compatibility)
                  if (connection.facebook_user_id === userId) {
                    // Events might be stored under the Facebook user ID
                    resolvedUserId = connection.facebook_user_id;
                    console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Found connection for Facebook user ${userId}, using Facebook user ID for comment lookup`);
                    listCommand = new ListObjectsV2Command({
                      Bucket: 'tasks',
                      Prefix: `FacebookEvents/${resolvedUserId}/`,
                    });
                    const result = await s3Client.send(listCommand);
                    Contents = result.Contents;
                    break;
                  }
                } catch (connectionError) {
                  console.error(`[${new Date().toISOString()}] Error reading connection file ${obj.Key}:`, connectionError.message);
                  continue;
                }
              }
            }
          }
        } catch (connectionSearchError) {
          console.error(`[${new Date().toISOString()}] Error searching Facebook connections for comments:`, connectionSearchError.message);
        }
      }
    }
    const comments = [];
    if (Contents && Contents.length > 0) {
      for (const obj of Contents) {
        if (obj.Key.endsWith('.json') && obj.Key.includes('comment_') && !obj.Key.includes('reply_')) {
          try {
            const getCommand = new GetObjectCommand({
              Bucket: 'tasks',
              Key: obj.Key,
            });
            const data = await s3Client.send(getCommand);
            const eventData = JSON.parse(await data.Body.transformToString());
            if (eventData.type === 'comment') {
              comments.push({
                type: 'comment',
                facebook_user_id: resolvedUserId,
                facebook_page_id: eventData.facebook_page_id,
                comment_id: eventData.comment_id,
                text: eventData.text,
                post_id: eventData.post_id,
                timestamp: new Date(eventData.received_at).getTime(),
                received_at: eventData.received_at,
                username: eventData.username || 'Unknown',
                status: eventData.status || 'pending',
                platform: 'facebook'
              });
            }
          } catch {}
        }
      }
    }
    console.log(`[${new Date().toISOString()}] [FACEBOOK-R2] Found ${comments.length} comments in R2 for user ${resolvedUserId}`);
    return comments;
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error fetching Facebook comments from R2 for ${userId}:`, error.message);
    return [];
  }
}

// Fetch Facebook DMs from API (fallback only)
async function fetchFacebookDMsFromAPI(userId, tokenData) {
  try {
    console.log(`[${new Date().toISOString()}] [FACEBOOK-API] Fetching DMs from API for ${userId} with page_id: ${tokenData.page_id}`);

    // Get Facebook page conversations
    const response = await axios.get(`https://graph.facebook.com/v19.0/${tokenData.page_id}/conversations`, {
      params: {
        access_token: tokenData.access_token,
        fields: 'participants,messages{message,from,created_time,id}',
        limit: 50
      }
    });

    const notifications = [];
    
    if (response.data && response.data.data) {
      console.log(`[${new Date().toISOString()}] [FACEBOOK-API] Found ${response.data.data.length} conversations for ${userId}`);
      for (const conversation of response.data.data) {
        if (conversation.messages && conversation.messages.data) {
          for (const message of conversation.messages.data) {
            // Skip messages from the page itself
            if (message.from && message.from.id !== tokenData.page_id) {
              notifications.push({
                type: 'message',
                facebook_user_id: userId,
                facebook_page_id: tokenData.page_id,
                sender_id: message.from.id,
                message_id: message.id,
                text: message.message || '',
                timestamp: new Date(message.created_time).getTime(),
                received_at: new Date().toISOString(),
                username: message.from.name || 'Unknown',
                status: 'pending',
                platform: 'facebook'
              });
            }
          }
        }
      }
    }
    
    console.log(`[${new Date().toISOString()}] [FACEBOOK-API] Successfully fetched ${notifications.length} DMs from API for ${userId}`);
    return notifications;
  } catch (error) {
    console.error(`[${new Date().toISOString()}] [FACEBOOK-API] Error fetching DMs from API for ${userId}:`, error.message);
    if (error.response) {
      console.error(`[${new Date().toISOString()}] [FACEBOOK-API] API error details:`, {
        status: error.response.status,
        statusText: error.response.statusText,
        data: error.response.data
      });
    }
    throw error; // Re-throw to let caller handle
  }
}

// Fetch Facebook comments from API (fallback only)
async function fetchFacebookCommentsFromAPI(userId, tokenData) {
  try {
    console.log(`[${new Date().toISOString()}] [FACEBOOK-API] Fetching comments from API for ${userId} with page_id: ${tokenData.page_id}`);

    // Get Facebook page posts and their comments
    const postsResponse = await axios.get(`https://graph.facebook.com/v19.0/${tokenData.page_id}/posts`, {
      params: {
        access_token: tokenData.access_token,
        fields: 'id,comments{message,from,created_time,id}',
        limit: 25
      }
    });

    const notifications = [];
    
    if (postsResponse.data && postsResponse.data.data) {
      console.log(`[${new Date().toISOString()}] [FACEBOOK-API] Found ${postsResponse.data.data.length} posts for ${userId}`);
      for (const post of postsResponse.data.data) {
        if (post.comments && post.comments.data) {
          console.log(`[${new Date().toISOString()}] [FACEBOOK-API] Found ${post.comments.data.length} comments for post ${post.id}`);
          for (const comment of post.comments.data) {
            // Skip comments from the page itself
            if (comment.from && comment.from.id !== tokenData.page_id) {
              notifications.push({
                type: 'comment',
                facebook_user_id: userId,
                facebook_page_id: tokenData.page_id,
                comment_id: comment.id,
                text: comment.message || '',
                post_id: post.id,
                timestamp: new Date(comment.created_time).getTime(),
                received_at: new Date().toISOString(),
                username: comment.from.name || 'Unknown',
                status: 'pending',
                platform: 'facebook'
              });
            }
          }
        }
      }
    }
    
    console.log(`[${new Date().toISOString()}] [FACEBOOK-API] Successfully fetched ${notifications.length} comments from API for ${userId}`);
    return notifications;
  } catch (error) {
    console.error(`[${new Date().toISOString()}] [FACEBOOK-API] Error fetching comments from API for ${userId}:`, error.message);
    if (error.response) {
      console.error(`[${new Date().toISOString()}] [FACEBOOK-API] API error details:`, {
        status: error.response.status,
        statusText: error.response.statusText,
        data: error.response.data
      });
    }
    throw error; // Re-throw to let caller handle
  }
}

// Legacy function - now just calls the new R2-first approach
async function fetchFacebookDMs(userId) {
  console.log(`[${new Date().toISOString()}] [FACEBOOK-LEGACY] fetchFacebookDMs called for ${userId} - using new R2-first approach`);
  const notifications = await fetchFacebookNotifications(userId);
  return notifications.filter(n => n.type === 'message');
}

// Legacy function - now just calls the new R2-first approach  
async function fetchFacebookComments(userId) {
  console.log(`[${new Date().toISOString()}] [FACEBOOK-LEGACY] fetchFacebookComments called for ${userId} - using new R2-first approach`);
  const notifications = await fetchFacebookNotifications(userId);
  return notifications.filter(n => n.type === 'comment');
}

async function getFacebookTokenData(userId) {
  try {
    console.log(`[${new Date().toISOString()}] getFacebookTokenData called with userId: ${userId}`);
    
    // Check Facebook connection for this user first - more efficient approach
    const connectionKey = `FacebookConnection/${userId}/connection.json`;
    console.log(`[${new Date().toISOString()}] Looking for connection at key: ${connectionKey}`);
    try {
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: connectionKey,
      });
      const data = await s3Client.send(getCommand);
      const connectionData = JSON.parse(await data.Body.transformToString());
      console.log(`[${new Date().toISOString()}] Found connection data for ${userId}:`, { 
        hasToken: !!connectionData.access_token, 
        pageId: connectionData.facebook_page_id,
        isPersonalAccount: connectionData.is_personal_account,
        detectionMethod: connectionData.page_detection_method
      });
      
      if (connectionData.access_token && connectionData.facebook_page_id) {
        // Return token data from connection - this is more efficient than separate storage
        const tokenData = {
          access_token: connectionData.access_token,
          user_access_token: connectionData.user_access_token, // Include user token for page token refresh
          page_id: connectionData.facebook_page_id,
          user_id: connectionData.facebook_user_id,
          username: connectionData.username,
          is_personal_account: connectionData.is_personal_account,
          page_detection_method: connectionData.page_detection_method
        };
        
        // For business pages, try to get a fresh page token using the user token
        if (!connectionData.is_personal_account && connectionData.user_access_token) {
          try {
            console.log(`[${new Date().toISOString()}] Getting fresh page token for business page ${connectionData.facebook_page_id}`);
            const freshPageToken = await getValidPageToken(connectionData.user_access_token, connectionData.facebook_page_id);
            
            if (freshPageToken) {
              tokenData.access_token = freshPageToken;
              console.log(`[${new Date().toISOString()}] Fresh page token obtained for ${connectionData.facebook_page_id}`);
            }
          } catch (pageTokenError) {
            console.log(`[${new Date().toISOString()}] Could not get fresh page token, using stored token:`, pageTokenError.response?.data || pageTokenError.message);
          }
        }
        
        return tokenData;
      }
    } catch (connectionError) {
      console.log(`[${new Date().toISOString()}] Facebook connection lookup failed for ${userId}, trying fallback methods...`);
    }

    // Fallback: try direct page lookup in FacebookTokens (legacy support)
    try {
      const directKey = `FacebookTokens/${userId}/token.json`;
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: directKey,
      });
      const data = await s3Client.send(getCommand);
      const json = await data.Body.transformToString();
      const token = JSON.parse(json);
      console.log(`[${new Date().toISOString()}] Found Facebook token data for ${userId}:`, {
        hasAccessToken: !!token.access_token,
        pageId: token.page_id,
        userId: token.user_id,
        isPersonalAccount: token.is_personal_account
      });
      
      // For business pages, try to get a fresh page token
      if (!token.is_personal_account && token.user_access_token) {
        try {
          console.log(`[${new Date().toISOString()}] Getting fresh page token for business page ${token.page_id}`);
          const freshPageToken = await getValidPageToken(token.user_access_token, token.page_id);
          
          if (freshPageToken) {
            token.access_token = freshPageToken;
            console.log(`[${new Date().toISOString()}] Fresh page token obtained for ${token.page_id}`);
          }
        } catch (pageTokenError) {
          console.log(`[${new Date().toISOString()}] Could not get fresh page token, using stored token:`, pageTokenError.response?.data || pageTokenError.message);
        }
      }
      
      return token;
    } catch (directError) {
      console.log(`[${new Date().toISOString()}] Direct Facebook token lookup failed for ${userId}`);
    }

    // Fallback: search all Facebook tokens for this user
    try {
      const listCommand = new ListObjectsV2Command({
        Bucket: 'tasks',
        Prefix: `FacebookTokens/`,
      });
      const { Contents } = await s3Client.send(listCommand);

      if (Contents) {
        for (const obj of Contents) {
          if (obj.Key.endsWith('/token.json')) {
            try {
              const getCommand = new GetObjectCommand({
                Bucket: 'tasks',
                Key: obj.Key,
              });
              const data = await s3Client.send(getCommand);
              const json = await data.Body.transformToString();
              const token = JSON.parse(json);
              
              // Check if this token belongs to the user (either by user_id or page_id)
              if (token.user_id === userId || token.page_id === userId) {
                                                 console.log(`[${new Date().toISOString()}] Found matching Facebook token for ${userId} in ${obj.Key}:`, {
                  hasAccessToken: !!token.access_token,
                  pageId: token.page_id,
                  userId: token.user_id,
                  isPersonalAccount: token.is_personal_account
                });
                
                // For business pages, try to get a fresh page token
                if (!token.is_personal_account && token.user_access_token) {
                  try {
                    console.log(`[${new Date().toISOString()}] Getting fresh page token for business page ${token.page_id}`);
                    const freshPageToken = await getValidPageToken(token.user_access_token, token.page_id);
                    
                    if (freshPageToken) {
                      token.access_token = freshPageToken;
                      console.log(`[${new Date().toISOString()}] Fresh page token obtained for ${token.page_id}`);
                    }
                  } catch (pageTokenError) {
                    console.log(`[${new Date().toISOString()}] Could not get fresh page token, using stored token:`, pageTokenError.response?.data || pageTokenError.message);
                  }
                }
                
                return token;
              }
            } catch (tokenError) {
              console.log(`[${new Date().toISOString()}] Error reading token from ${obj.Key}:`, tokenError.message);
              continue;
            }
          }
        }
      }
    } catch (searchError) {
      console.log(`[${new Date().toISOString()}] Error searching Facebook tokens:`, searchError.message);
    }
    
    console.log(`[${new Date().toISOString()}] No Facebook token data found for ${userId}`);
    return null;
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error getting Facebook token data for ${userId}:`, error.message);
    return null;
  }
}

async function sendFacebookDMReply(userId, senderId, text, messageId) {
  try {
    console.log(`[${new Date().toISOString()}] Sending Facebook DM reply from ${userId} to ${senderId}: ${text}`);
    
    // Get Facebook access token
    const tokenData = await getFacebookTokenData(userId);
    if (!tokenData) {
      throw new Error('No Facebook token found for user');
    }

    console.log(`[${new Date().toISOString()}] Facebook token data for DM reply:`, {
      hasToken: !!tokenData.access_token,
      pageId: tokenData.page_id,
      userId: tokenData.user_id,
      isPersonalAccount: tokenData.is_personal_account
    });

    // Use the token data directly (page token refresh is now handled in getFacebookTokenData)
    let accessToken = tokenData.access_token;
    let pageId = tokenData.page_id;

    console.log(`[${new Date().toISOString()}] Sending DM using page ID: ${pageId}, token type: ${tokenData.is_personal_account ? 'user' : 'page'}`);

    // Send the message via Facebook Messenger API
    const response = await axios.post(`https://graph.facebook.com/v19.0/${pageId}/messages`, {
      recipient: { id: senderId },
      message: { text }
    }, {
      params: {
        access_token: accessToken
      }
    });

    console.log(`[${new Date().toISOString()}] Facebook DM reply sent successfully`);
    return { success: true, message_id: response.data.message_id };
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error sending Facebook DM reply:`, error.response?.data || error.message);
    throw error;
  }
}

async function sendFacebookCommentReply(userId, commentId, text) {
  try {
    console.log(`[${new Date().toISOString()}] Sending Facebook comment reply from ${userId} to comment ${commentId}: ${text}`);
    
    // Get Facebook access token
    const tokenData = await getFacebookTokenData(userId);
    if (!tokenData) {
      throw new Error('No Facebook token found for user');
    }

    console.log(`[${new Date().toISOString()}] Facebook token data for comment reply:`, {
      hasToken: !!tokenData.access_token,
      pageId: tokenData.page_id,
      userId: tokenData.user_id,
      isPersonalAccount: tokenData.is_personal_account
    });

    // Use the token data directly (page token refresh is now handled in getFacebookTokenData)
    let accessToken = tokenData.access_token;

    console.log(`[${new Date().toISOString()}] Sending comment reply using token type: ${tokenData.is_personal_account ? 'user' : 'page'}`);

    // Reply to comment via Facebook Graph API
    const response = await axios.post(`https://graph.facebook.com/v19.0/${commentId}/comments`, {
      message: text
    }, {
      params: {
        access_token: accessToken
      }
    });

    console.log(`[${new Date().toISOString()}] Facebook comment reply sent successfully`);
    return { success: true, comment_id: response.data.id };
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error sending Facebook comment reply:`, error.response?.data || error.message);
    throw error;
  }
}

router.post('/store-instagram-connection/:userId', async (req, res) => {
  const { userId } = req.params;
  const { instagram_user_id, instagram_graph_id, username } = req.body;
  
  if (!instagram_user_id || !instagram_graph_id) {
    return res.status(400).json({ error: 'Instagram user ID and graph ID are required' });
  }
  
  try {
    const key = `InstagramConnection/${userId}/connection.json`;
    const connectionData = {
      uid: userId,
      instagram_user_id,
      instagram_graph_id,
      username: username || '',
      lastUpdated: new Date().toISOString()
    };
    
    const putCommand = new PutObjectCommand({
      Bucket: 'tasks',
      Key: key,
      Body: JSON.stringify(connectionData, null, 2),
      ContentType: 'application/json',
    });
    
    await s3Client.send(putCommand);
    res.json({ success: true, message: 'Instagram connection stored successfully' });
  } catch (error) {
    console.error(`Error storing Instagram connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to store Instagram connection' });
  }
});

// This endpoint deletes the user's Instagram connection
router.delete('/instagram-connection/:userId', async (req, res) => {
  // Set CORS headers
  setCorsHeaders(res);
  
  const { userId } = req.params;
  
  try {
    const key = `InstagramConnection/${userId}/connection.json`;
    
    try {
      // Check if the file exists first
      const headCommand = new HeadObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      await s3Client.send(headCommand);
      
      // If it exists, delete it
      const deleteCommand = new DeleteObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      await s3Client.send(deleteCommand);
      
      res.json({ success: true, message: 'Instagram connection deleted successfully' });
    } catch (error) {
      if (error.name === 'NotFound' || error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
        return res.status(404).json({ error: 'No Instagram connection found to delete' });
      }
      throw error;
    }
  } catch (error) {
    console.error(`Error deleting Instagram connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to delete Instagram connection' });
  }
});

// Add OPTIONS handlers for Instagram connection endpoints
router.options('/instagram-connection/:userId', (req, res) => {
  setCorsHeaders(res);
  res.status(204).send();
});

router.options('/user-instagram-status/:userId', (req, res) => {
  setCorsHeaders(res);
  res.status(204).send();
});

// This endpoint checks if a user has entered their Instagram username
router.get(['/user-instagram-status/:userId', '/api/user-instagram-status/:userId'], async (req, res) => {
  // Set CORS headers
  setCorsHeaders(res);
  
  const { userId } = req.params;
  
  try {
    const key = `UserInstagramStatus/${userId}/status.json`;
    
    try {
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      const response = await s3Client.send(getCommand);
      const body = await streamToString(response.Body);
      
      if (!body || body.trim() === '') {
        return res.json({ hasEnteredInstagramUsername: false });
      }
      
      const userData = JSON.parse(body);
      return res.json(userData);
    } catch (error) {
      if (error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
        return res.json({ hasEnteredInstagramUsername: false });
      }
      throw error;
    }
  } catch (error) {
    console.error(`Error retrieving user Instagram status for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to retrieve user Instagram status' });
  }
});

// This endpoint updates the user's Instagram username entry state
router.post(['/user-instagram-status/:userId', '/api/user-instagram-status/:userId'], async (req, res) => {
  setCorsHeaders(res);
  const { userId } = req.params;
  const { instagram_username } = req.body;
  if (!instagram_username || !instagram_username.trim()) {
    return res.status(400).json({ error: 'Instagram username is required' });
  }
  try {
    const key = `UserInstagramStatus/${userId}/status.json`;
    const userData = {
      uid: userId,
      hasEnteredInstagramUsername: true,
      instagram_username: instagram_username.trim(),
      lastUpdated: new Date().toISOString()
    };
    const putCommand = new PutObjectCommand({
      Bucket: 'tasks',
      Key: key,
      Body: JSON.stringify(userData, null, 2),
      ContentType: 'application/json',
    });
    await s3Client.send(putCommand);
    res.json({ success: true, message: 'User Instagram status updated successfully' });
  } catch (error) {
    console.error(`Error updating user Instagram status for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to update user Instagram status' });
  }
});

// This endpoint updates the user's Facebook username entry state
router.post(['/user-facebook-status/:userId', '/api/user-facebook-status/:userId'], async (req, res) => {
  setCorsHeaders(res);
  const { userId } = req.params;
  const { facebook_username } = req.body;
  if (!facebook_username || !facebook_username.trim()) {
    return res.status(400).json({ error: 'Facebook username is required' });
  }
  try {
    const key = `UserFacebookStatus/${userId}/status.json`;
    const userData = {
      uid: userId,
      hasEnteredFacebookUsername: true,
      facebook_username: facebook_username.trim(),
      lastUpdated: new Date().toISOString()
    };
    const putCommand = new PutObjectCommand({
      Bucket: 'tasks',
      Key: key,
      Body: JSON.stringify(userData, null, 2),
      ContentType: 'application/json',
    });
    await s3Client.send(putCommand);
    res.json({ success: true, message: 'User Facebook status updated successfully' });
  } catch (error) {
    console.error(`Error updating user Facebook status for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to update user Facebook status' });
  }
});

// Instagram connection endpoints (GET endpoint was missing)
router.get(['/instagram-connection/:userId', '/api/instagram-connection/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  
  try {
    const key = `InstagramConnection/${userId}/connection.json`;
    
    try {
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      const response = await s3Client.send(getCommand);
      const body = await streamToString(response.Body);
      
      if (!body || body.trim() === '') {
        return res.status(404).json({ error: 'No Instagram connection found' });
      }
      
      const connectionData = JSON.parse(body);
      return res.json(connectionData);
    } catch (error) {
      if (error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
        return res.status(404).json({ error: 'No Instagram connection found' });
      }
      throw error;
    }
  } catch (error) {
    console.error(`Error retrieving Instagram connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to retrieve Instagram connection' });
  }
});

router.post(['/instagram-connection/:userId', '/api/instagram-connection/:userId'], async (req, res) => {
  setCorsHeaders(res);
  const { userId } = req.params;
  const { instagram_user_id, instagram_graph_id, username } = req.body;
  // Log for debugging
  console.log('[DEBUG] Instagram connection POST body:', req.body);
  if (!instagram_user_id || !instagram_graph_id) {
    return res.status(400).json({ error: 'Instagram user ID and graph ID are required' });
  }
  try {
    const key = `InstagramConnection/${userId}/connection.json`;
    const connectionData = {
      uid: userId,
      instagram_user_id,
      instagram_graph_id,
      username: username || '',
      lastUpdated: new Date().toISOString()
    };
    const putCommand = new PutObjectCommand({
      Bucket: 'tasks',
      Key: key,
      Body: JSON.stringify(connectionData, null, 2),
      ContentType: 'application/json',
    });
    await s3Client.send(putCommand);
    res.json({ success: true, message: 'Instagram connection stored successfully' });
  } catch (error) {
    console.error(`Error storing Instagram connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to store Instagram connection' });
  }
});

// Instagram token check endpoint
router.get('/instagram-token-check/:graphId', async (req, res) => {
  setCorsHeaders(res);
  
  const { graphId } = req.params;
  
  try {
    const key = `InstagramTokens/${graphId}/token.json`;
    
    try {
      const headCommand = new HeadObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      await s3Client.send(headCommand);
      
      // Token exists
      res.json({ exists: true, message: 'Instagram token found' });
    } catch (error) {
      if (error.name === 'NotFound' || error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
        // Always return 200 with exists: false
        return res.json({ exists: false, message: 'No Instagram token found' });
      }
      throw error;
    }
  } catch (error) {
    console.error(`Error checking Instagram token for graph ID ${graphId}:`, error);
    res.status(500).json({ error: 'Failed to check Instagram token' });
  }
});

// Real-time Instagram posting endpoint
router.post(['/api/post-instagram-now/:userId', '/post-instagram-now/:userId'], upload.single('image'), async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  const { caption } = req.body;
  const file = req.file;

  console.log(`[${new Date().toISOString()}] Real-time Instagram post request for user ${userId}: image=${!!file}, caption=${!!caption}`);

  if (!file) {
    return res.status(400).json({ error: 'Image is required for Instagram posts' });
  }

  if (!caption || caption.trim() === '') {
    return res.status(400).json({ error: 'Caption is required for Instagram posts' });
  }

  try {
    // Get Instagram token data - the userId could be either instagram_user_id or instagram_graph_id
    let tokenData = null;
    
    // First try to get token data using userId as graph_id
    try {
      tokenData = await getTokenData(userId);
    } catch (error) {
      // If that fails, search by instagram_user_id
      console.log(`[${new Date().toISOString()}] Token not found using ${userId} as graph_id, searching by user_id...`);
      
      const listCommand = new ListObjectsV2Command({
        Bucket: 'tasks',
        Prefix: `InstagramTokens/`,
      });
      const { Contents } = await s3Client.send(listCommand);

      if (Contents) {
        for (const obj of Contents) {
          if (obj.Key.endsWith('/token.json')) {
            const getCommand = new GetObjectCommand({
              Bucket: 'tasks',
              Key: obj.Key,
            });
            const data = await s3Client.send(getCommand);
            const json = await data.Body.transformToString();
            const token = JSON.parse(json);
            if (token.instagram_user_id === userId) {
              tokenData = token;
              console.log(`[${new Date().toISOString()}] Found token by instagram_user_id: ${userId}`);
              break;
            }
          }
        }
      }
    }
    
    if (!tokenData) {
      console.log(`[${new Date().toISOString()}] No Instagram token found for user ${userId} (tried both graph_id and user_id)`);
      return res.status(404).json({ error: 'No Instagram access token found for this account. Please reconnect Instagram.' });
    }

    const { access_token, instagram_graph_id } = tokenData;
    
    console.log(`[${new Date().toISOString()}] Posting to Instagram with graph ID: ${instagram_graph_id}`);

    // Step 1: Upload image to Instagram
    let imageBuffer = file.buffer;
    
    // Detect actual image format from file content (magic bytes)
    let actualFormat = 'unknown';
    let mimeType = file.mimetype;
    
    // Debug: Log the first few bytes to understand what we're dealing with
    const firstBytes = imageBuffer.slice(0, 16);
    console.log(`[${new Date().toISOString()}] [DEBUG] Image format detection - First 16 bytes:`, Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join(' '));
    console.log(`[${new Date().toISOString()}] [DEBUG] Reported mimetype: ${file.mimetype}`);
    
    if (imageBuffer.length >= 4) {
      // Check for JPEG signature (FF D8)
      if (imageBuffer[0] === 0xFF && imageBuffer[1] === 0xD8) {
        actualFormat = 'jpeg';
        mimeType = 'image/jpeg';
      }
      // Check for PNG signature (89 50 4E 47)
      else if (imageBuffer[0] === 0x89 && imageBuffer[1] === 0x50 && 
               imageBuffer[2] === 0x4E && imageBuffer[3] === 0x47) {
        actualFormat = 'png';
        mimeType = 'image/png';
      }
      // Check for RIFF format (WebP or other RIFF formats) - Convert all to JPEG for Instagram compatibility
      else if (imageBuffer.length >= 4 &&
               imageBuffer.toString('ascii', 0, 4) === 'RIFF') {
        console.log(`[${new Date().toISOString()}] RIFF format detected, converting to JPEG for Instagram compatibility...`);
        
        try {
          // Convert to JPEG using sharp (handles both valid and corrupted WebP)
          imageBuffer = await sharp(imageBuffer)
            .jpeg({ 
              quality: 85, // High quality JPEG
              progressive: true 
            })
            .toBuffer();
          
          // Update format and mimetype after conversion
          actualFormat = 'jpeg';
          mimeType = 'image/jpeg';
          
          console.log(`[${new Date().toISOString()}] RIFF successfully converted to JPEG for Instagram posting (${imageBuffer.length} bytes)`);
        } catch (conversionError) {
          console.error(`[${new Date().toISOString()}] RIFF to JPEG conversion failed:`, conversionError);
          
          // If conversion fails, try to create a placeholder image
          try {
            imageBuffer = await generatePlaceholderImage('Image conversion failed', 512, 512);
            actualFormat = 'jpeg';
            mimeType = 'image/jpeg';
            console.log(`[${new Date().toISOString()}] Generated placeholder image for failed conversion`);
          } catch (placeholderError) {
            console.error(`[${new Date().toISOString()}] Failed to generate placeholder:`, placeholderError);
            return res.status(500).json({ error: 'Image processing failed' });
          }
        }
      }
    }
    
    // Validate that we detected a supported format
    if (!['jpeg', 'png'].includes(actualFormat)) {
      return res.status(400).json({ 
        error: `Unsupported image format detected. Instagram API only supports JPEG and PNG images.`,
        details: `Detected format: ${actualFormat}. Reported mimetype: ${file.mimetype}`
      });
    }
    
    // Validate image size (Instagram requires minimum 320px and max 8MB)
    if (imageBuffer.length > 8 * 1024 * 1024) {
      return res.status(400).json({ error: 'Image too large. Maximum file size is 8MB for Instagram posts.' });
    }
    
    const imageBase64 = imageBuffer.toString('base64');
    
    console.log(`[${new Date().toISOString()}] Uploading ${mimeType} image to Instagram (${imageBuffer.length} bytes)...`);
    
    // === New implementation: store image in R2 and use a short-lived signed URL ===
    // Ensure proper file extension for Instagram (jpeg -> jpg)
    const fileExtension = actualFormat === 'jpeg' ? 'jpg' : actualFormat;
    const r2Key = `temp_instagram_uploads/${userId}/${Date.now()}_${Math.random().toString(36).substring(7)}.${fileExtension}`;
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: r2Key,
      Body: imageBuffer,
      ContentType: mimeType,
      ACL: 'public-read'
    }));

    // Generate a 15-minute signed URL for the image
    const publicImageUrl = await getSignedUrl(
      s3Client,
      new GetObjectCommand({ Bucket: 'tasks', Key: r2Key }),
      { expiresIn: 900 }
    );
    console.log(`[${new Date().toISOString()}] Image uploaded to R2 for Instagram access: ${publicImageUrl}`);

    // Upload image and create media object using public URL
    const mediaResponse = await axios.post(`https://graph.instagram.com/v22.0/${instagram_graph_id}/media`, {
      image_url: publicImageUrl,
      caption: caption.trim(),
      access_token: access_token
    }, {
      headers: {
        'Content-Type': 'application/json'
      }
    });

    const mediaId = mediaResponse.data.id;
    console.log(`[${new Date().toISOString()}] Instagram media created with ID: ${mediaId}`);

    // Step 2: Publish the media
    console.log(`[${new Date().toISOString()}] Publishing Instagram media...`);
    
    const publishResponse = await axios.post(`https://graph.instagram.com/v22.0/${instagram_graph_id}/media_publish`, {
      creation_id: mediaId,
      access_token: access_token
    }, {
      headers: {
        'Content-Type': 'application/json'
      }
    });

    const postId = publishResponse.data.id;
    console.log(`[${new Date().toISOString()}] Instagram post published successfully with ID: ${postId}`);

    // Step 3: Store post record for tracking
    const postKey = `InstagramPosts/${userId}/${postId}.json`;
    const postData = {
      id: postId,
      userId,
      platform: 'instagram',
      caption: caption.trim(),
      media_id: mediaId,
      instagram_graph_id,
      posted_at: new Date().toISOString(),
      status: 'published',
      type: 'real_time_post'
    };

    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: postKey,
      Body: JSON.stringify(postData, null, 2),
      ContentType: 'application/json',
    }));

    console.log(`[${new Date().toISOString()}] Instagram post record stored at ${postKey}`);

    res.json({ 
      success: true, 
      message: 'Instagram post published successfully!',
      post_id: postId,
      media_id: mediaId,
      posted_at: postData.posted_at
    });

  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error posting to Instagram:`, error.response?.data || error.message);
    
    let errorMessage = 'Failed to post to Instagram';
    if (error.response?.data?.error?.message) {
      errorMessage = error.response.data.error.message;
    } else if (error.response?.data?.error) {
      errorMessage = error.response.data.error;
    } else if (error.message) {
      errorMessage = error.message;
    }
    
    res.status(500).json({ 
      error: errorMessage,
      details: error.response?.data || error.message 
    });
  }
});

// ============= INSTAGRAM SCHEDULING ENDPOINT =============

// Schedule Instagram post endpoint - matches our successful real-time implementation
router.post(['/api/schedule-post/:userId', '/schedule-post/:userId'], upload.single('image'), async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  const { caption, scheduleDate, platform = 'instagram' } = req.body;
  const file = req.file;

  console.log(`[${new Date().toISOString()}] Schedule post request for user ${userId}: image=${!!file}, caption=${!!caption}, scheduleDate=${scheduleDate}`);

  if (!file || !caption || !scheduleDate) {
    return res.status(400).json({ error: 'Missing required fields: image, caption, or scheduleDate' });
  }

  try {
    // Validate schedule date
    const scheduledTime = new Date(scheduleDate);
    const now = new Date();
    const maxFutureDate = new Date(now.getTime() + 75 * 24 * 60 * 60 * 1000); // 75 days max

    if (scheduledTime <= now) {
      return res.status(400).json({ error: 'Schedule date must be in the future' });
    }

    if (scheduledTime > maxFutureDate) {
      return res.status(400).json({ error: 'Schedule date cannot be more than 75 days in the future' });
    }

    // Use the same image processing logic as our successful real-time posting
    let imageBuffer = file.buffer;
    
    // Detect actual image format from file content (magic bytes)
    let actualFormat = 'unknown';
    let mimeType = file.mimetype;
    
    if (imageBuffer.length >= 4) {
      // Check for JPEG signature (FF D8)
      if (imageBuffer[0] === 0xFF && imageBuffer[1] === 0xD8) {
        actualFormat = 'jpeg';
        mimeType = 'image/jpeg';
      }
      // Check for PNG signature (89 50 4E 47)
      else if (imageBuffer[0] === 0x89 && imageBuffer[1] === 0x50 && 
               imageBuffer[2] === 0x4E && imageBuffer[3] === 0x47) {
        actualFormat = 'png';
        mimeType = 'image/png';
      }
      // Check for WebP signature (RIFF + WEBP) - Strict validation
      else if (imageBuffer.length >= 12 &&
               imageBuffer.toString('ascii', 0, 4) === 'RIFF' &&
               imageBuffer.toString('ascii', 8, 12) === 'WEBP') {
        actualFormat = 'webp';
        console.log(`[${new Date().toISOString()}] Valid WebP image detected in scheduled post, converting to JPEG...`);
        
        try {
          // Convert WebP to JPEG using sharp
          imageBuffer = await sharp(imageBuffer)
            .jpeg({ 
              quality: 85, // High quality JPEG
              progressive: true 
            })
            .toBuffer();
          
          // Update format and mimetype after conversion
          actualFormat = 'jpeg';
          mimeType = 'image/jpeg';
          
          console.log(`[${new Date().toISOString()}] WebP successfully converted to JPEG for scheduled post (${imageBuffer.length} bytes)`);
        } catch (conversionError) {
          console.error(`[${new Date().toISOString()}] WebP conversion failed for scheduled post:`, conversionError);
          
          // If it's a corrupt header error, treat as JPEG instead of failing
          if (conversionError.message.includes('corrupt header') || conversionError.message.includes('unable to parse')) {
            console.log(`[${new Date().toISOString()}] Corrupt WebP detected, treating as JPEG for scheduling`);
            actualFormat = 'jpeg';
            mimeType = 'image/jpeg';
          } else {
            return res.status(400).json({ 
              error: 'Failed to convert WebP image to JPEG format.',
              details: 'There was an issue converting your WebP image. Please try with a JPEG or PNG image instead.'
            });
          }
        }
      }
      // Handle RIFF format that's not WebP - treat as JPEG
      else if (imageBuffer.length >= 4 &&
               imageBuffer.toString('ascii', 0, 4) === 'RIFF') {
        console.log(`[${new Date().toISOString()}] RIFF format detected but not WebP, treating as JPEG for scheduling`);
        actualFormat = 'jpeg';
        mimeType = 'image/jpeg';
      }
    }
    
    // Validate that we detected a supported format
    if (!['jpeg', 'png'].includes(actualFormat)) {
      return res.status(400).json({ 
        error: `Unsupported image format detected. Instagram API only supports JPEG and PNG images.`,
        details: `Detected format: ${actualFormat}. Reported mimetype: ${file.mimetype}`
      });
    }
    
    // Validate image size (Instagram requirements)
    if (imageBuffer.length > 8 * 1024 * 1024) {
      return res.status(400).json({ error: 'Image too large. Maximum file size is 8MB for Instagram posts.' });
    }

    // Generate unique keys for storage
    const scheduleId = `schedule_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const finalFormat = actualFormat === 'jpeg' ? 'jpg' : actualFormat;
    if (finalFormat !== actualFormat) {
      console.log(`[${new Date().toISOString()}] Renaming scheduled image extension to .${finalFormat}`);
      actualFormat = finalFormat;
    }
    const imageKey = `scheduled_posts/${platform}/${userId}/${scheduleId}.${actualFormat}`;
    const scheduleKey = `scheduled_posts/${platform}/${userId}/${scheduleId}.json`;

    // Store image in R2
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: imageKey,
      Body: imageBuffer,
      ContentType: mimeType,
    }));

    // Store schedule data
    const scheduleData = {
      id: scheduleId,
      userId,
      platform,
      caption: caption.trim(),
      scheduleDate: scheduledTime.toISOString(),
      imageKey,
      imageFormat: actualFormat,
      status: 'scheduled',
      createdAt: new Date().toISOString(),
      attempts: 0
    };

    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: scheduleKey,
      Body: JSON.stringify(scheduleData, null, 2),
      ContentType: 'application/json',
    }));

    console.log(`[${new Date().toISOString()}] Post scheduled successfully: ${scheduleId} for ${scheduledTime.toISOString()}`);

    res.json({ 
      success: true, 
      message: 'Post scheduled successfully!',
      scheduleId,
      scheduledFor: scheduledTime.toISOString(),
      imageFormat: actualFormat
    });

  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error scheduling post:`, error.message);
    res.status(500).json({ 
      error: 'Failed to schedule post',
      details: error.message 
    });
  }
});

// ============= FACEBOOK DEBUG ENDPOINTS =============

// Debug endpoint to test Facebook token and API access
router.get(['/facebook-debug/:userId', '/api/facebook-debug/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  
  try {
    console.log(`[${new Date().toISOString()}] Facebook debug request for userId: ${userId}`);
    
    // Check connection storage first
    let connectionData = null;
    try {
      const connectionKey = `FacebookConnection/${userId}/connection.json`;
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: connectionKey,
      });
      const data = await s3Client.send(getCommand);
      connectionData = JSON.parse(await data.Body.transformToString());
      console.log(`[${new Date().toISOString()}] Connection data found:`, {
        hasAccessToken: !!connectionData.access_token,
        pageId: connectionData.facebook_page_id,
        userId: connectionData.facebook_user_id
      });
    } catch (connectionError) {
      console.log(`[${new Date().toISOString()}] No connection data found for ${userId}:`, connectionError.message);
    }
    
    // Get token data
    const tokenData = await getFacebookTokenData(userId);
    if (!tokenData) {
      return res.json({ 
        error: 'No Facebook token found',
        userId,
        connectionData,
        timestamp: new Date().toISOString()
      });
    }
    
    console.log(`[${new Date().toISOString()}] Token data found for debug:`, {
      hasAccessToken: !!tokenData.access_token,
      pageId: tokenData.page_id,
      userId: tokenData.user_id,
      isPersonalAccount: tokenData.is_personal_account,
      pageDetectionMethod: tokenData.page_detection_method
    });
    
    // Enhanced page detection analysis with comprehensive testing
    let pageDetectionAnalysis = null;
    try {
      console.log(`[${new Date().toISOString()}] Starting comprehensive Facebook API analysis for ${userId}`);
      
      // Test 1: Basic API access
      const meResponse = await axios.get(`https://graph.facebook.com/v19.0/me`, {
        params: {
          access_token: tokenData.access_token,
          fields: 'id,name'
        }
      });
      
      // Test 2: Safe page-specific access without problematic fields
      const pageResponse = await axios.get(`https://graph.facebook.com/v19.0/${tokenData.page_id}`, {
        params: {
          access_token: tokenData.access_token,
          fields: 'id,name' // Only request safe fields to avoid errors
        }
      });
      
      // Test 3: Pages list (Meta's recommended approach)
      const pagesResponse = await axios.get(`https://graph.facebook.com/v19.0/me/accounts`, {
        params: {
          access_token: tokenData.access_token,
          fields: 'id,name,category,fan_count,followers_count,page_type,verification_status'
        }
      });
      
      // Test 4: User permissions
      const permissionsResponse = await axios.get(`https://graph.facebook.com/v19.0/me/permissions`, {
        params: {
          access_token: tokenData.access_token
        }
      });
      
      // Test 5: User capabilities for business account detection (only for user accounts, not pages)
      let capabilitiesResponse = null;
      try {
        capabilitiesResponse = await axios.get(`https://graph.facebook.com/v19.0/me`, {
          params: {
            access_token: tokenData.access_token,
            fields: 'id,name,accounts,business_users'
          }
        });
      } catch (capabilitiesError) {
        console.log(`[${new Date().toISOString()}] Capabilities check failed (expected for pages):`, capabilitiesError.response?.data?.error?.message || capabilitiesError.message);
        // For pages, we don't need capabilities check
        capabilitiesResponse = { data: { id: tokenData.page_id, name: tokenData.pageName || 'Unknown' } };
      }
      
      // Smart analysis based on permissions and capabilities (avoiding problematic field access)
      const hasBusinessPermissions = permissionsResponse.data.data?.some(perm => 
        (perm.permission.includes('pages_') || perm.permission.includes('instagram_') || perm.permission.includes('whatsapp_')) && 
        perm.status === 'granted'
      );
      
      const hasPagePermissions = permissionsResponse.data.data?.some(perm => 
        perm.permission.includes('pages_') && perm.status === 'granted'
      );
      
      const hasBusinessCapabilities = capabilitiesResponse.data.accounts || 
                                    capabilitiesResponse.data.business_users;
      
      const hasPagesList = pagesResponse.data.data && pagesResponse.data.data.length > 0;
      
      // Smart detection: If user has business permissions, they should be treated as business page
      const shouldBeBusinessPage = hasBusinessPermissions || hasBusinessCapabilities || hasPagesList;
      
      pageDetectionAnalysis = {
        // API Responses
        meData: meResponse.data,
        pageData: pageResponse.data,
        pagesList: pagesResponse.data,
        permissions: permissionsResponse.data,
        capabilities: capabilitiesResponse.data,
        
        // Detection Analysis
        analysis: {
          // Permission-based indicators (safe)
          hasBusinessPermissions,
          hasPagePermissions,
          hasBusinessCapabilities,
          hasPagesList,
          
          // Safe page indicators
          hasPageAccess: !!pageResponse.data.id,
          pageName: pageResponse.data.name,
          
          // Detection logic
          shouldBeBusinessPage,
          isBusinessAccount: hasBusinessPermissions || hasBusinessCapabilities,
          hasManagePermissions: hasPagePermissions
        },
        
        // Detection accuracy
        detectionAccuracy: {
          currentDetection: tokenData.is_personal_account ? 'Personal Account' : 'Business Page',
          recommendedDetection: shouldBeBusinessPage ? 'Business Page' : 'Personal Account',
          isCorrectlyDetected: shouldBeBusinessPage === !tokenData.is_personal_account,
          detectionMethod: tokenData.page_detection_method
        }
      };
      
    } catch (analysisError) {
      console.error(`[${new Date().toISOString()}] Error during Facebook API analysis:`, analysisError.response?.data || analysisError.message);
      pageDetectionAnalysis = {
        error: analysisError.response?.data || analysisError.message,
        status: analysisError.response?.status,
        message: 'Failed to analyze Facebook account type'
      };
    }
    
    // Test conversations access
    let conversationsTestResult = null;
    try {
      const conversationsResponse = await axios.get(`https://graph.facebook.com/v19.0/${tokenData.page_id}/conversations`, {
        params: {
          access_token: tokenData.access_token,
          fields: 'participants',
          limit: 5
        }
      });
      conversationsTestResult = {
        success: true,
        data: conversationsResponse.data
      };
    } catch (conversationsError) {
      conversationsTestResult = {
        success: false,
        error: conversationsError.response?.data || conversationsError.message,
        status: conversationsError.response?.status
      };
    }
    
    res.json({
      userId,
      connectionData,
      tokenData: {
        hasAccessToken: !!tokenData.access_token,
        pageId: tokenData.page_id,
        userId: tokenData.user_id,
        isPersonalAccount: tokenData.is_personal_account,
        pageDetectionMethod: tokenData.page_detection_method,
        pageName: tokenData.page_name
      },
      pageDetectionAnalysis,
      conversationsTest: conversationsTestResult,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Facebook debug error for ${userId}:`, error);
    res.status(500).json({ 
      error: 'Facebook debug failed',
      message: error.message,
      userId,
      timestamp: new Date().toISOString()
    });
  }
});

// ============= FACEBOOK CONNECTION ENDPOINTS =============

// Facebook connection endpoints
router.get(['/facebook-connection/:userId', '/api/facebook-connection/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  
  try {
    const key = `FacebookConnection/${userId}/connection.json`;
    
    try {
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      const response = await s3Client.send(getCommand);
      const body = await streamToString(response.Body);
      
      if (!body || body.trim() === '') {
        // Always return 200 with error JSON
        return res.json({ error: 'No Facebook connection found' });
      }
      
      const connectionData = JSON.parse(body);
      return res.json(connectionData);
    } catch (error) {
      if (error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
        // Always return 200 with error JSON
        return res.json({ error: 'No Facebook connection found' });
      }
      throw error;
    }
  } catch (error) {
    console.error(`Error retrieving Facebook connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to retrieve Facebook connection' });
  }
});

router.post(['/facebook-connection/:userId', '/api/facebook-connection/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  const { facebook_user_id, facebook_page_id, access_token, username } = req.body;
  
  if (!facebook_user_id || !facebook_page_id || !access_token) {
    return res.status(400).json({ error: 'Facebook user ID, page ID, and access token are required' });
  }
  
  try {
    const key = `FacebookConnection/${userId}/connection.json`;
    const connectionData = {
      uid: userId,
      facebook_user_id,
      facebook_page_id,
      username: username || '',
      access_token,
      lastUpdated: new Date().toISOString()
    };
    
    const putCommand = new PutObjectCommand({
      Bucket: 'tasks',
      Key: key,
      Body: JSON.stringify(connectionData, null, 2),
      ContentType: 'application/json',
    });
    
    await s3Client.send(putCommand);
    res.json({ success: true, message: 'Facebook connection stored successfully' });
  } catch (error) {
    console.error(`Error storing Facebook connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to store Facebook connection' });
  }
});

router.delete(['/facebook-connection/:userId', '/api/facebook-connection/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  
  try {
    const key = `FacebookConnection/${userId}/connection.json`;
    
    try {
      const headCommand = new HeadObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      await s3Client.send(headCommand);
      
      const deleteCommand = new DeleteObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      await s3Client.send(deleteCommand);
      
      res.json({ success: true, message: 'Facebook connection deleted successfully' });
    } catch (error) {
      if (error.name === 'NotFound' || error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
        return res.status(404).json({ error: 'No Facebook connection found to delete' });
      }
      throw error;
    }
  } catch (error) {
    console.error(`Error deleting Facebook connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to delete Facebook connection' });
  }
});

// Facebook user status endpoints
router.get(['/user-facebook-status/:userId', '/api/user-facebook-status/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  
  try {
    const key = `UserFacebookStatus/${userId}/status.json`;
    
    try {
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      const response = await s3Client.send(getCommand);
      const body = await streamToString(response.Body);
      
      if (!body || body.trim() === '') {
        return res.json({ hasEnteredFacebookUsername: false });
      }
      
      const userData = JSON.parse(body);
      return res.json(userData);
    } catch (error) {
      if (error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
        return res.json({ hasEnteredFacebookUsername: false });
      }
      throw error;
    }
  } catch (error) {
    console.error(`Error retrieving user Facebook status for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to retrieve user Facebook status' });
  }
});

router.post(['/user-facebook-status/:userId', '/api/user-facebook-status/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  const { facebook_username } = req.body;
  
  if (!facebook_username || !facebook_username.trim()) {
    return res.status(400).json({ error: 'Facebook username is required' });
  }
  
  try {
    const key = `UserFacebookStatus/${userId}/status.json`;
    const userData = {
      uid: userId,
      hasEnteredFacebookUsername: true,
      facebook_username: facebook_username.trim(),
      lastUpdated: new Date().toISOString()
    };
    
    const putCommand = new PutObjectCommand({
      Bucket: 'tasks',
      Key: key,
      Body: JSON.stringify(userData, null, 2),
      ContentType: 'application/json',
    });
    
    await s3Client.send(putCommand);
    res.json({ success: true, message: 'User Facebook status updated successfully' });
  } catch (error) {
    console.error(`Error updating user Facebook status for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to update user Facebook status' });
  }
});

// Add OPTIONS handlers for Facebook endpoints
router.options(['/facebook-connection/:userId', '/api/facebook-connection/:userId'], (req, res) => {
  setCorsHeaders(res);
  res.status(204).send();
});

router.options(['/user-facebook-status/:userId', '/api/user-facebook-status/:userId'], (req, res) => {
  setCorsHeaders(res);
  res.status(204).send();
});

router.post(['/instagram-connection/:userId', '/api/instagram-connection/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  const { instagram_user_id, instagram_graph_id, username } = req.body;
  
  if (!instagram_user_id || !instagram_graph_id) {
    return res.status(400).json({ error: 'Instagram user ID and graph ID are required' });
  }
  
  try {
    const key = `InstagramConnection/${userId}/connection.json`;
    const connectionData = {
      uid: userId,
      instagram_user_id,
      instagram_graph_id,
      username: username || '',
      lastUpdated: new Date().toISOString()
    };
    
    const putCommand = new PutObjectCommand({
      Bucket: 'tasks',
      Key: key,
      Body: JSON.stringify(connectionData, null, 2),
      ContentType: 'application/json',
    });
    
    await s3Client.send(putCommand);
    res.json({ success: true, message: 'Instagram connection stored successfully' });
  } catch (error) {
    console.error(`Error storing Instagram connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to store Instagram connection' });
  }
});

// =================== FACEBOOK CONNECTION ENDPOINTS ===================

// This endpoint retrieves the user's Facebook connection
router.get(['/facebook-connection/:userId', '/api/facebook-connection/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  
  try {
    const key = `FacebookConnection/${userId}/connection.json`;
    
    try {
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      const response = await s3Client.send(getCommand);
      const body = await streamToString(response.Body);
      
      if (!body || body.trim() === '') {
        // Always return 200 with error JSON
        return res.json({ error: 'No Facebook connection found' });
      }
      
      const connectionData = JSON.parse(body);
      return res.json(connectionData);
    } catch (error) {
      if (error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
        // Always return 200 with error JSON
        return res.json({ error: 'No Facebook connection found' });
      }
      throw error;
    }
  } catch (error) {
    console.error(`Error retrieving Facebook connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to retrieve Facebook connection' });
  }
});

// This endpoint stores the user's Facebook connection
router.post(['/facebook-connection/:userId', '/api/facebook-connection/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  const { facebook_user_id, username } = req.body;
  
  if (!facebook_user_id) {
    return res.status(400).json({ error: 'Facebook user ID is required' });
  }
  
  try {
    const key = `FacebookConnection/${userId}/connection.json`;
    const connectionData = {
      uid: userId,
      facebook_user_id,
      username: username || '',
      lastUpdated: new Date().toISOString()
    };
    
    const putCommand = new PutObjectCommand({
      Bucket: 'tasks',
      Key: key,
      Body: JSON.stringify(connectionData, null, 2),
      ContentType: 'application/json',
    });
    
    await s3Client.send(putCommand);
    res.json({ success: true, message: 'Facebook connection stored successfully' });
  } catch (error) {
    console.error(`Error storing Facebook connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to store Facebook connection' });
  }
});

// This endpoint deletes the user's Facebook connection
router.delete(['/facebook-connection/:userId', '/api/facebook-connection/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  
  try {
    const key = `FacebookConnection/${userId}/connection.json`;
    
    try {
      // Check if the file exists first
      const headCommand = new HeadObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      await s3Client.send(headCommand);
      
      // If it exists, delete it
      const deleteCommand = new DeleteObjectCommand({
        Bucket: 'tasks',
        Key: key,
      });
      await s3Client.send(deleteCommand);
      
      res.json({ success: true, message: 'Facebook connection deleted successfully' });
    } catch (error) {
      if (error.name === 'NotFound' || error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
        return res.status(404).json({ error: 'No Facebook connection found to delete' });
      }
      throw error;
    }
  } catch (error) {
    console.error(`Error deleting Facebook connection for ${userId}:`, error);
    res.status(500).json({ error: 'Failed to delete Facebook connection' });
  }
});

// Add OPTIONS handlers for Facebook connection endpoints
router.options(['/facebook-connection/:userId', '/api/facebook-connection/:userId'], (req, res) => {
  setCorsHeaders(res);
  res.status(204).send();
});

// ============= POST SCHEDULING ENDPOINTS =============

// DUPLICATE ENDPOINT REMOVED - Using the comprehensive one above with WebP auto-conversion and better error handling

// Get scheduled posts for a user
router.get(['/scheduled-posts/:userId', '/api/scheduled-posts/:userId'], async (req, res) => {
  setCorsHeaders(res);
  
  const { userId } = req.params;
  const platform = req.query.platform || 'instagram';
  
  try {
    const prefix = platform === 'facebook' ? `FacebookScheduled/${userId}/` : `InstagramScheduled/${userId}/`;
    const listCommand = new ListObjectsV2Command({
      Bucket: 'tasks',
      Prefix: prefix
    });
    
    const listResponse = await s3Client.send(listCommand);
    const files = listResponse.Contents || [];
    
    const scheduledPosts = await Promise.all(
      files
        .filter(file => file.Key.endsWith('.json'))
        .map(async (file) => {
          try {
            const getCommand = new GetObjectCommand({
              Bucket: 'tasks',
              Key: file.Key
            });
            const data = await s3Client.send(getCommand);
            const postData = JSON.parse(await streamToString(data.Body));
            
            return {
              ...postData,
              key: file.Key,
              lastModified: file.LastModified
            };
          } catch (error) {
            console.error(`Error reading scheduled post ${file.Key}:`, error);
            return null;
          }
        })
    );
    
    const validPosts = scheduledPosts.filter(post => post !== null);
    res.json(validPosts);
  } catch (error) {
    console.error(`Error fetching scheduled ${platform} posts:`, error);
    res.status(500).json({ error: `Failed to fetch scheduled ${platform} posts` });
  }
});

// ============= INSIGHTS ENDPOINTS =============

// Unified insights endpoint for all platforms
router.get(['/insights/:userId', '/api/insights/:userId'], async (req, res) => {
  setCorsHeaders(res);
  const { userId } = req.params;
  const platform = req.query.platform || 'instagram';
  console.log(`[${new Date().toISOString()}] Fetching ${platform} insights for user ${userId}`);
  try {
    if (platform === 'facebook') {
      const tokenData = await getFacebookTokenData(userId);
      if (!tokenData) {
        return res.status(200).json({ error: 'No Facebook token found for this user' });
      }
      const insights = await fetchFacebookInsights(tokenData.page_id, tokenData.access_token);
      res.json(insights);
    } else if (platform === 'instagram') {
      let tokenData;
      try {
        tokenData = await getTokenData(userId);
      } catch (err) {
        return res.status(200).json({ error: 'No Instagram token found for this user' });
      }
      if (!tokenData) {
        return res.status(200).json({ error: 'No Instagram token found for this user' });
      }
      const insights = await fetchInstagramInsights(tokenData.instagram_graph_id, tokenData.access_token);
      res.json(insights);
    } else {
      res.status(400).json({ error: 'Unsupported platform for insights' });
    }
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error fetching ${platform} insights:`, error);
    res.status(500).json({ error: `Failed to fetch ${platform} insights` });
  }
});



// ======================== TWITTER OAUTH 2.0 & POSTING IMPLEMENTATION ========================

// Twitter OAuth 2.0 credentials
const TWITTER_CLIENT_ID = 'cVNYR3UxVm5jQ3d5UWw0UHFqUTI6MTpjaQ';
const TWITTER_CLIENT_SECRET = 'Wr8Kewh92NVB-035hAvpQeQ1Azc7chre3PUTgDoEltjO57mxzO';
const TWITTER_REDIRECT_URI = 'https://www.sentientm.com/twitter/callback';

// Debug logging for OAuth 2.0
console.log(`[${new Date().toISOString()}] Twitter OAuth 2.0 Configuration:`);
console.log(`[${new Date().toISOString()}] Client ID: ${TWITTER_CLIENT_ID}`);
console.log(`[${new Date().toISOString()}] Redirect URI: ${TWITTER_REDIRECT_URI}`);

// OAuth 2.0 PKCE helper functions
function generateCodeVerifier() {
  return crypto.randomBytes(32).toString('base64url');
}

function generateCodeChallenge(codeVerifier) {
  return crypto.createHash('sha256').update(codeVerifier).digest('base64url');
}

// Store for PKCE state (in production, use secure session store)
const pkceStore = new Map();

// Twitter OAuth 2.0 - Step 1: Generate authorization URL
router.get(['/twitter/auth', '/api/twitter/auth'], async (req, res) => {
  setCorsHeaders(res, req.headers.origin || '*');
  
  const { userId } = req.query; // Firebase user ID
  
  if (!userId) {
    return res.status(400).json({ error: 'Firebase userId is required' });
  }
  
  try {
    console.log(`[${new Date().toISOString()}] Starting Twitter OAuth 2.0 flow for Firebase user ${userId}...`);
    
    // Generate PKCE parameters
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = generateCodeChallenge(codeVerifier);
    const state = crypto.randomBytes(16).toString('hex');
    
    // Store PKCE parameters for verification
    pkceStore.set(state, {
      codeVerifier,
      codeChallenge,
      firebaseUserId: userId, // Store Firebase user ID
      timestamp: Date.now()
    });
    
    // Clean up old PKCE entries (older than 10 minutes)
    for (const [key, value] of pkceStore.entries()) {
      if (Date.now() - value.timestamp > 10 * 60 * 1000) {
        pkceStore.delete(key);
      }
    }
    
    // Build authorization URL
    const scopes = [
      'tweet.read',
      'tweet.write', 
      'users.read',
      'offline.access'
    ].join(' ');
    
    const authParams = new URLSearchParams({
      response_type: 'code',
      client_id: TWITTER_CLIENT_ID,
      redirect_uri: TWITTER_REDIRECT_URI,
      scope: scopes,
      state: state,
      code_challenge: codeChallenge,
      code_challenge_method: 'S256'
    });
    
    const authUrl = `https://x.com/i/oauth2/authorize?${authParams.toString()}`;
    
    console.log(`[${new Date().toISOString()}] Generated Twitter OAuth 2.0 auth URL`);
    console.log(`[${new Date().toISOString()}] State: ${state}`);
    console.log(`[${new Date().toISOString()}] Code challenge: ${codeChallenge}`);
    
    res.json({ authUrl, state });
    
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Twitter OAuth 2.0 step 1 error:`, error.message);
    res.status(500).json({ 
      error: 'Failed to initiate Twitter OAuth 2.0', 
      details: error.message 
    });
  }
});

// Twitter OAuth 2.0 - Step 2: Handle callback and exchange code for access token
router.get(['/twitter/callback', '/api/twitter/callback'], async (req, res) => {
  const { code, state } = req.query;
  
  if (!code || !state) {
    console.log(`[${new Date().toISOString()}] Twitter callback failed: Missing code or state`);
    return res.status(400).send('Error: Missing OAuth parameters');
  }
  
  try {
    console.log(`[${new Date().toISOString()}] Processing Twitter OAuth 2.0 callback...`);
    
    // Retrieve stored PKCE parameters
    const pkceData = pkceStore.get(state);
    if (!pkceData) {
      throw new Error('Invalid state parameter or expired PKCE data');
    }
    
    // Clean up used PKCE data
    pkceStore.delete(state);
    
    // Exchange authorization code for access token
    const tokenRequestBody = new URLSearchParams({
      grant_type: 'authorization_code',
      code: code,
      redirect_uri: TWITTER_REDIRECT_URI,
      code_verifier: pkceData.codeVerifier
    });
    
    // For confidential clients (Web Apps), use Basic Auth header
    const basicAuthCredentials = Buffer.from(`${TWITTER_CLIENT_ID}:${TWITTER_CLIENT_SECRET}`).toString('base64');
    
    console.log(`[${new Date().toISOString()}] Exchanging code for access token...`);
    console.log(`[${new Date().toISOString()}] Using Basic Auth for confidential client`);
    
    const response = await axios.post('https://api.x.com/2/oauth2/token', tokenRequestBody, {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json',
        'Authorization': `Basic ${basicAuthCredentials}`
      }
    });
    
    const tokenData = response.data;
    
    if (!tokenData.access_token) {
      throw new Error('Failed to get access token from Twitter');
    }
    
    console.log(`[${new Date().toISOString()}] Got access token, fetching user info...`);
    
    // Get user information using the access token
    const userResponse = await axios.get('https://api.x.com/2/users/me', {
      headers: {
        'Authorization': `Bearer ${tokenData.access_token}`,
        'Content-Type': 'application/json'
      }
    });
    
    const userData = userResponse.data.data;
    const userId = userData.id;
    const username = userData.username;
    
    console.log(`[${new Date().toISOString()}] Twitter OAuth 2.0 successful: user_id=${userId}, username=${username}`);
    
    // Store access token in R2
    const userTokenKey = `TwitterTokens/${userId}/token.json`;
    const userTokenData = {
      twitter_user_id: userId,
      access_token: tokenData.access_token,
      refresh_token: tokenData.refresh_token || null,
      token_type: tokenData.token_type || 'Bearer',
      expires_in: tokenData.expires_in || 7200,
      scope: tokenData.scope || '',
      username: username,
      expires_at: new Date(Date.now() + (tokenData.expires_in || 7200) * 1000).toISOString(),
      timestamp: new Date().toISOString()
    };
    
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: userTokenKey,
      Body: JSON.stringify(userTokenData, null, 2),
      ContentType: 'application/json'
    }));
    
    console.log(`[${new Date().toISOString()}] Twitter tokens stored for user ${userId}`);
    
    // Also store connection data for frontend detection
    const connectionKey = `UserTwitterConnection/${pkceData.firebaseUserId}/connection.json`;
    const connectionData = {
      twitter_user_id: userId,
      username: username,
      connected_at: new Date().toISOString(),
      user_id: pkceData.firebaseUserId
    };
    
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: connectionKey,
      Body: JSON.stringify(connectionData, null, 2),
      ContentType: 'application/json'
    }));
    
    console.log(`[${new Date().toISOString()}] Twitter connection data stored for Firebase user ${pkceData.firebaseUserId}`);
    
    // Send success response with JavaScript to notify parent window
    res.send(`
      <html>
        <body>
          <h2>Twitter Connected Successfully!</h2>
          <p>Username: @${username}</p>
          <p>User ID: ${userId}</p>
          <p>Token expires in: ${Math.floor((tokenData.expires_in || 7200) / 3600)} hours</p>
          <p>You can now close this window and return to the dashboard.</p>
          <script>
            window.opener.postMessage({ 
              type: 'TWITTER_CONNECTED', 
              userId: '${userId}', 
              username: '${username}',
              accessToken: '${tokenData.access_token}'
            }, '*');
            window.close();
          </script>
        </body>
      </html>
    `);
    
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Twitter OAuth 2.0 callback error:`, error.response?.data || error.message);
    console.error(`[${new Date().toISOString()}] Full error details:`, {
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      headers: error.response?.headers,
      config: {
        url: error.config?.url,
        method: error.config?.method,
        data: error.config?.data
      }
    });
    res.status(500).send(`Error completing Twitter authentication: ${error.message}`);
  }
});

// Post tweet endpoint - immediate posting with OAuth 2.0
router.post(['/post-tweet/:userId', '/api/post-tweet/:userId'], async (req, res) => {
  setCorsHeaders(res, req.headers.origin || '*');
  
  const { userId } = req.params;
  const { text } = req.body;
  
  if (!text || text.trim().length === 0) {
    return res.status(400).json({ error: 'Tweet text is required' });
  }
  
  if (text.length > 280) {
    return res.status(400).json({ error: 'Tweet text exceeds 280 characters' });
  }
  
  try {
    console.log(`[${new Date().toISOString()}] Posting tweet for user ${userId}: "${text}"`);
    
    // Get user's stored Twitter tokens
    const userTokenKey = `TwitterTokens/${userId}/token.json`;
    let tokenData;
    
    try {
      const getCommand = new GetObjectCommand({
        Bucket: 'tasks',
        Key: userTokenKey
      });
      const response = await s3Client.send(getCommand);
      tokenData = JSON.parse(await streamToString(response.Body));
    } catch (error) {
      if (error.name === 'NoSuchKey') {
        return res.status(404).json({ error: 'Twitter account not connected' });
      }
      throw error;
    }
    
    // Check if token is expired and needs refresh
    if (tokenData.expires_at && new Date() > new Date(tokenData.expires_at)) {
      console.log(`[${new Date().toISOString()}] Access token expired, attempting to refresh...`);
      
      if (tokenData.refresh_token) {
        try {
          // Refresh the access token
          const refreshBody = new URLSearchParams({
            grant_type: 'refresh_token',
            refresh_token: tokenData.refresh_token
          });
          
          // Use Basic Auth header for confidential clients
          const basicAuthCredentials = Buffer.from(`${TWITTER_CLIENT_ID}:${TWITTER_CLIENT_SECRET}`).toString('base64');
          
          const refreshResponse = await axios.post('https://api.x.com/2/oauth2/token', refreshBody, {
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              'Accept': 'application/json',
              'Authorization': `Basic ${basicAuthCredentials}`
            }
          });
          
          const newTokenData = refreshResponse.data;
          
          // Update stored token data
          tokenData.access_token = newTokenData.access_token;
          tokenData.refresh_token = newTokenData.refresh_token || tokenData.refresh_token;
          tokenData.expires_in = newTokenData.expires_in || 7200;
          tokenData.expires_at = new Date(Date.now() + (newTokenData.expires_in || 7200) * 1000).toISOString();
          
          // Save updated token
          await s3Client.send(new PutObjectCommand({
            Bucket: 'tasks',
            Key: userTokenKey,
            Body: JSON.stringify(tokenData, null, 2),
            ContentType: 'application/json'
          }));
          
          console.log(`[${new Date().toISOString()}] Access token refreshed successfully`);
        } catch (refreshError) {
          console.error(`[${new Date().toISOString()}] Token refresh failed:`, refreshError.response?.data || refreshError.message);
          return res.status(401).json({ 
            error: 'Token expired and refresh failed', 
            details: 'Please reconnect your Twitter account' 
          });
        }
      } else {
        return res.status(401).json({ 
          error: 'Access token expired', 
          details: 'Please reconnect your Twitter account' 
        });
      }
    }
    
    // Post tweet using Twitter API v2 with OAuth 2.0 Bearer token
    const tweetData = { text: text.trim() };
    
    const response = await axios.post('https://api.x.com/2/tweets', tweetData, {
      headers: {
        'Authorization': `Bearer ${tokenData.access_token}`,
        'Content-Type': 'application/json'
      }
    });
    
    const tweetId = response.data.data.id;
    const tweetText = response.data.data.text;
    
    console.log(`[${new Date().toISOString()}] Tweet posted successfully: ID ${tweetId}`);
    
    // Store tweet record for tracking
    const tweetKey = `TwitterPosts/${userId}/${tweetId}.json`;
    const tweetRecord = {
      tweet_id: tweetId,
      text: tweetText,
      user_id: userId,
      posted_at: new Date().toISOString(),
      scheduled: false,
      status: 'posted'
    };
    
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: tweetKey,
      Body: JSON.stringify(tweetRecord, null, 2),
      ContentType: 'application/json'
    }));
    
    res.json({ 
      success: true, 
      tweet_id: tweetId, 
      text: tweetText,
      message: 'Tweet posted successfully' 
    });
    
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error posting tweet:`, error.response?.data || error.message);
    
    if (error.response?.status === 401) {
      res.status(401).json({ 
        error: 'Twitter authentication failed', 
        details: 'Please reconnect your Twitter account' 
      });
    } else if (error.response?.status === 403) {
      res.status(403).json({ 
        error: 'Tweet posting forbidden', 
        details: error.response?.data?.detail || 'Check your Twitter API permissions and scopes' 
      });
    } else {
      res.status(500).json({ 
        error: 'Failed to post tweet', 
        details: error.response?.data || error.message 
      });
    }
  }
});

// Schedule tweet endpoint - for future posting
router.post(['/schedule-tweet/:userId', '/api/schedule-tweet/:userId'], async (req, res) => {
  setCorsHeaders(res, req.headers.origin || '*');
  
  const { userId } = req.params;
  const { text, scheduled_time } = req.body;
  
  if (!text || text.trim().length === 0) {
    return res.status(400).json({ error: 'Tweet text is required' });
  }
  
  if (text.length > 280) {
    return res.status(400).json({ error: 'Tweet text exceeds 280 characters' });
  }
  
  if (!scheduled_time) {
    return res.status(400).json({ error: 'Scheduled time is required' });
  }
  
  const scheduledDate = new Date(scheduled_time);
  if (scheduledDate <= new Date()) {
    return res.status(400).json({ error: 'Scheduled time must be in the future' });
  }
  
  try {
    console.log(`[${new Date().toISOString()}] Scheduling tweet for user ${userId} at ${scheduledDate.toISOString()}: "${text}"`);
    
    // Verify user has Twitter connected
    const userTokenKey = `TwitterTokens/${userId}/token.json`;
    try {
      await s3Client.send(new HeadObjectCommand({
        Bucket: 'tasks',
        Key: userTokenKey
      }));
    } catch (error) {
      if (error.name === 'NoSuchKey') {
        return res.status(404).json({ error: 'Twitter account not connected' });
      }
      throw error;
    }
    
    // Store scheduled tweet
    const scheduleId = randomUUID();
    const scheduleKey = `TwitterScheduled/${userId}/${scheduleId}.json`;
    const scheduledTweet = {
      schedule_id: scheduleId,
      user_id: userId,
      text: text.trim(),
      scheduled_time: scheduledDate.toISOString(),
      created_at: new Date().toISOString(),
      status: 'scheduled'
    };
    
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: scheduleKey,
      Body: JSON.stringify(scheduledTweet, null, 2),
      ContentType: 'application/json'
    }));
    
    console.log(`[${new Date().toISOString()}] Tweet scheduled with ID ${scheduleId}`);
    
    res.json({ 
      success: true, 
      schedule_id: scheduleId,
      scheduled_time: scheduledDate.toISOString(),
      message: 'Tweet scheduled successfully' 
    });
    
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error scheduling tweet:`, error.message);
    res.status(500).json({ 
      error: 'Failed to schedule tweet', 
      details: error.message 
    });
  }
});

// Schedule tweet endpoint - for future posting with OAuth 2.0
router.post(['/schedule-tweet/:userId', '/api/schedule-tweet/:userId'], async (req, res) => {
  setCorsHeaders(res, req.headers.origin || '*');
  
  const { userId } = req.params;
  const { text, scheduled_time } = req.body;
  
  if (!text || text.trim().length === 0) {
    return res.status(400).json({ error: 'Tweet text is required' });
  }
  
  if (text.length > 280) {
    return res.status(400).json({ error: 'Tweet text exceeds 280 characters' });
  }
  
  if (!scheduled_time) {
    return res.status(400).json({ error: 'Scheduled time is required' });
  }
  
  const scheduleDate = new Date(scheduled_time);
  const now = new Date();
  
  if (scheduleDate <= now) {
    return res.status(400).json({ error: 'Scheduled time must be in the future' });
  }
  
  try {
    console.log(`[${new Date().toISOString()}] Scheduling tweet for user ${userId} at ${scheduleDate.toISOString()}: "${text}"`);
    
    // Generate unique schedule ID
    const scheduleId = crypto.randomUUID();
    
    // Store scheduled tweet in R2
    const scheduledTweetKey = `TwitterScheduled/${userId}/${scheduleId}.json`;
    const scheduledTweetData = {
      id: scheduleId,
      user_id: userId,
      text: text.trim(),
      scheduled_time: scheduleDate.toISOString(),
      created_at: new Date().toISOString(),
      status: 'pending',
      type: 'text_only'
    };
    
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: scheduledTweetKey,
      Body: JSON.stringify(scheduledTweetData, null, 2),
      ContentType: 'application/json'
    }));
    
    console.log(`[${new Date().toISOString()}] Scheduled tweet stored with ID ${scheduleId}`);
    
    res.json({ 
      success: true, 
      message: 'Tweet scheduled successfully',
      schedule_id: scheduleId,
      scheduled_time: scheduleDate.toISOString()
    });
    
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error scheduling tweet:`, error);
    res.status(500).json({ error: 'Failed to schedule tweet' });
  }
});

// Schedule tweet with image endpoint - for future posting with OAuth 2.0 and image
router.post(['/schedule-tweet-with-image/:userId', '/api/schedule-tweet-with-image/:userId'], upload.single('image'), async (req, res) => {
  setCorsHeaders(res, req.headers.origin || '*');
  
  const { userId } = req.params;
  
  // Debug: Log all received data
  console.log(`[${new Date().toISOString()}] POST /schedule-tweet-with-image/${userId} - Request received`);
  console.log(`[${new Date().toISOString()}] req.body:`, req.body);
  console.log(`[${new Date().toISOString()}] req.files:`, req.files ? Object.keys(req.files) : 'none');
  
  // Get fields from req.body (FormData puts text fields in req.body)
  const text = req.body.text;
  const scheduled_time = req.body.scheduled_time;
  const imageFile = req.files?.image || req.file;
  
  console.log(`[${new Date().toISOString()}] Extracted text: "${text}"`);
  console.log(`[${new Date().toISOString()}] Extracted scheduled_time: "${scheduled_time}"`);
  console.log(`[${new Date().toISOString()}] Image file present: ${!!imageFile}`);
  
  // Allow empty text if there's an image (Twitter allows image-only posts)
  if (text && text.length > 280) {
    return res.status(400).json({ error: 'Tweet text exceeds 280 characters' });
  }
  
  if (!scheduled_time) {
    return res.status(400).json({ error: 'Scheduled time is required' });
  }
  
  if (!imageFile) {
    return res.status(400).json({ error: 'Image file is required' });
  }
  
  // If no text provided, use empty string (Twitter allows image-only posts)
  const tweetText = text ? text.trim() : '';
  
  const scheduleDate = new Date(scheduled_time);
  const now = new Date();
  
  if (scheduleDate <= now) {
    return res.status(400).json({ error: 'Scheduled time must be in the future' });
  }
  
  try {
    console.log(`[${new Date().toISOString()}] Scheduling tweet with image for user ${userId} at ${scheduleDate.toISOString()}: "${tweetText}"`);
    
    // Generate unique schedule ID
    const scheduleId = crypto.randomUUID();
    
    // Store image in R2
    const imageKey = `TwitterScheduled/${userId}/${scheduleId}_image.jpg`;
    const imageBuffer = imageFile.buffer || imageFile.data;
    
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: imageKey,
      Body: imageBuffer,
      ContentType: imageFile.mimetype || 'image/jpeg'
    }));
    
    // Store scheduled tweet data in R2
    const scheduledTweetKey = `TwitterScheduled/${userId}/${scheduleId}.json`;
    const scheduledTweetData = {
      id: scheduleId,
      user_id: userId,
      text: tweetText,
      scheduled_time: scheduleDate.toISOString(),
      created_at: new Date().toISOString(),
      status: 'pending',
      type: 'with_image',
      image_key: imageKey
    };
    
    await s3Client.send(new PutObjectCommand({
      Bucket: 'tasks',
      Key: scheduledTweetKey,
      Body: JSON.stringify(scheduledTweetData, null, 2),
      ContentType: 'application/json'
    }));
    
    console.log(`[${new Date().toISOString()}] Scheduled tweet with image stored with ID ${scheduleId}`);
    
    res.json({ 
      success: true, 
      message: 'Tweet with image scheduled successfully',
      schedule_id: scheduleId,
      scheduled_time: scheduleDate.toISOString()
    });
    
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error scheduling tweet with image:`, error);
    res.status(500).json({ error: 'Failed to schedule tweet with image' });
  }
});

// Get scheduled tweets for a user
router.get(['/scheduled-tweets/:userId', '/api/scheduled-tweets/:userId'], async (req, res) => {
  setCorsHeaders(res, req.headers.origin || '*');
  
  const { userId } = req.params;
  
  try {
    const listCommand = new ListObjectsV2Command({
      Bucket: 'tasks',
      Prefix: `TwitterScheduled/${userId}/`
    });
    
    const listResponse = await s3Client.send(listCommand);
    const files = listResponse.Contents || [];
    
    const scheduledTweets = await Promise.all(
      files.map(async (file) => {
        try {
          const getCommand = new GetObjectCommand({
            Bucket: 'tasks',
            Key: file.Key
          });
          const data = await s3Client.send(getCommand);
          const tweetData = JSON.parse(await streamToString(data.Body));
          
          return {
            key: file.Key,
            ...tweetData
          };
        } catch (error) {
          console.error(`Error reading scheduled tweet ${file.Key}:`, error);
          return null;
        }
      })
    );
    
    const validTweets = scheduledTweets.filter(tweet => tweet !== null);
    
    // Sort by scheduled time
    validTweets.sort((a, b) => new Date(a.scheduled_time).getTime() - new Date(b.scheduled_time).getTime());
    
    res.json(validTweets);
    
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error fetching scheduled tweets:`, error);
    res.status(500).json({ 
      error: 'Failed to fetch scheduled tweets', 
      details: error.message 
    });
  }
});

// Delete scheduled tweet
router.delete(['/scheduled-tweet/:userId/:scheduleId', '/api/scheduled-tweet/:userId/:scheduleId'], async (req, res) => {
  setCorsHeaders(res, req.headers.origin || '*');
  
  const { userId, scheduleId } = req.params;
  
  try {
    const scheduleKey = `TwitterScheduled/${userId}/${scheduleId}.json`;
    
    await s3Client.send(new DeleteObjectCommand({
      Bucket: 'tasks',
      Key: scheduleKey
    }));
    
    console.log(`[${new Date().toISOString()}] Deleted scheduled tweet ${scheduleId} for user ${userId}`);
    
    res.json({ success: true, message: 'Scheduled tweet deleted' });
    
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error deleting scheduled tweet:`, error);
    res.status(500).json({ 
      error: 'Failed to delete scheduled tweet', 
      details: error.message 
    });
  }
});


// Helper function to get valid page token using user token
async function getValidPageToken(userToken, pageId) {
  try {
    const res = await axios.get(
      `https://graph.facebook.com/v19.0/me/accounts?access_token=${userToken}`
    );
    const pages = res.data.data;
    const pageData = pages.find(p => p.id === pageId);
    return pageData?.access_token || null;
  } catch (e) {
    console.error("[TOKEN] Failed to fetch page token:", e.response?.data || e.message);
    return null;
  }
}

// Facebook token validation and refresh helper
async function validateAndRefreshFacebookToken(userId, tokenData) {
  try {
    console.log(`[${new Date().toISOString()}] Validating Facebook token for ${userId}`);
    
    // Test the token by making a simple API call
    const testResponse = await axios.get(`https://graph.facebook.com/v19.0/me`, {
      params: {
        access_token: tokenData.access_token,
        fields: 'id,name'
      }
    });
    
    console.log(`[${new Date().toISOString()}] Facebook token validation successful for ${userId}`);
    return tokenData;
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Facebook token validation failed for ${userId}:`, error.message);
    
    if (error.response && error.response.status === 400) {
      console.log(`[${new Date().toISOString()}] Token appears to be expired for ${userId}, attempting refresh...`);
      
      // Try to refresh the token using the app secret
      try {
        const refreshResponse = await axios.get('https://graph.facebook.com/v19.0/oauth/access_token', {
          params: {
            grant_type: 'fb_exchange_token',
            client_id: FB_APP_ID,
            client_secret: FB_APP_SECRET,
            fb_exchange_token: tokenData.access_token
          }
        });
        
        if (refreshResponse.data.access_token) {
          console.log(`[${new Date().toISOString()}] Successfully refreshed Facebook token for ${userId}`);
          
          // Update the token in storage
          const updatedTokenData = {
            ...tokenData,
            access_token: refreshResponse.data.access_token
          };
          
          // Store the refreshed token
          const tokenKey = `FacebookTokens/${userId}/token.json`;
          const putCommand = new PutObjectCommand({
            Bucket: 'tasks',
            Key: tokenKey,
            Body: JSON.stringify(updatedTokenData, null, 2),
            ContentType: 'application/json',
          });
          
          await s3Client.send(putCommand);
          console.log(`[${new Date().toISOString()}] Updated Facebook token in storage for ${userId}`);
          
          return updatedTokenData;
        }
      } catch (refreshError) {
        console.error(`[${new Date().toISOString()}] Failed to refresh Facebook token for ${userId}:`, refreshError.message);
      }
    }
    
    return null;
  }
}

// Facebook insights helper function
async function fetchFacebookInsights(pageId, accessToken) {
  const insights = {
    reach: { daily: [], weekly: [], monthly: [] },
    impressions: { daily: [], weekly: [], monthly: [] },
    online_followers: { daily: [] },
    accounts_engaged: { daily: [] },
    total_interactions: { daily: [] },
    follower_demographics: { lifetime: {} }
  };

  try {
    // First, check if this is a Page or a User account
    let pageInfoResponse;
    let isBusinessPage = false;
    
    try {
      // Try page-specific fields first - using latest API version v23.0
      console.log(`[${new Date().toISOString()}] Attempting to fetch Facebook page info for ${pageId} with page-specific fields`);
      pageInfoResponse = await axios.get(`https://graph.facebook.com/v23.0/${pageId}`, {
        params: {
          fields: 'id,name,category,followers_count,fan_count,page_type',
          access_token: accessToken
        }
      });
      
      console.log(`[${new Date().toISOString()}] Facebook page API response:`, {
        id: pageInfoResponse.data.id,
        name: pageInfoResponse.data.name,
        category: pageInfoResponse.data.category,
        followers_count: pageInfoResponse.data.followers_count,
        fan_count: pageInfoResponse.data.fan_count,
        page_type: pageInfoResponse.data.page_type
      });
      
      // Check if we got page-specific data
      if (pageInfoResponse.data && (pageInfoResponse.data.category || pageInfoResponse.data.followers_count !== undefined || pageInfoResponse.data.fan_count !== undefined)) {
        isBusinessPage = true;
        console.log(`[${new Date().toISOString()}] Detected Facebook business page: ${pageId} (category: ${pageInfoResponse.data.category})`);
      } else {
        // If no page-specific fields, try user fields
        console.log(`[${new Date().toISOString()}] No page-specific fields found, trying user API for ${pageId}`);
        try {
          const userResponse = await axios.get(`https://graph.facebook.com/v23.0/${pageId}`, {
            params: {
              fields: 'id,name',
              access_token: accessToken
            }
          });
          isBusinessPage = false;
          console.log(`[${new Date().toISOString()}] Detected Facebook personal account: ${pageId}`);
        } catch (userError) {
          // If both fail, assume it's a business page but with limited access
          console.log(`[${new Date().toISOString()}] Both page and user API calls failed for ${pageId}, assuming business page with limited access`);
          isBusinessPage = true;
          pageInfoResponse = { data: { id: pageId, name: 'Unknown Page' } };
        }
      }
    } catch (pageError) {
      console.log(`[${new Date().toISOString()}] Page API call failed for ${pageId}, trying user API:`, pageError.response?.data?.error?.message || pageError.message);
      
      // If page fields fail, try user fields
      try {
        console.log(`[${new Date().toISOString()}] Attempting to fetch Facebook user info for ${pageId}`);
        pageInfoResponse = await axios.get(`https://graph.facebook.com/v23.0/${pageId}`, {
          params: {
            fields: 'id,name',
            access_token: accessToken
          }
        });
        isBusinessPage = false;
        console.log(`[${new Date().toISOString()}] Detected Facebook personal account: ${pageId}`);
      } catch (userError) {
        console.error(`[${new Date().toISOString()}] Error fetching page/user info:`, userError.response?.data || userError.message);
        
        // If both API calls fail, assume it's a business page but with limited access
        console.log(`[${new Date().toISOString()}] Both API calls failed for ${pageId}, assuming business page with limited access`);
        isBusinessPage = true;
        pageInfoResponse = { data: { id: pageId, name: 'Unknown Page' } };
      }
    }
    
        if (isBusinessPage) {
      // This is a business page - fetch available insights (some metrics were deprecated)
      console.log(`[${new Date().toISOString()}] Fetching insights for Facebook business page ${pageId}`);
      
      const baseUrl = `https://graph.facebook.com/v23.0/${pageId}/insights`;
      
      // Check if page has 100+ likes (required for insights)
      const followerCount = pageInfoResponse.data.followers_count || pageInfoResponse.data.fan_count || 0;
      
      if (followerCount < 100) {
        console.log(`[${new Date().toISOString()}] Page has less than 100 likes (${followerCount}), insights not available`);
        
        // Return structure with zero/empty data and explanation
        const last30Days = Array.from({ length: 30 }, (_, i) => {
          const date = new Date();
          date.setDate(date.getDate() - (29 - i));
          return date.toISOString().split('T')[0] + 'T00:00:00.000Z';
        });

        insights.reach.daily = last30Days.map(date => ({ date, value: 0 }));
        insights.impressions.daily = last30Days.map(date => ({ date, value: 0 }));
        insights.accounts_engaged.daily = last30Days.map(date => ({ date, value: 0 }));
        insights.total_interactions.daily = last30Days.map(date => ({ date, value: 0 }));
        insights.online_followers.daily = last30Days.map(date => ({ date, value: 0 }));
        
        insights.isNewPage = true;
        insights.followerCount = followerCount;
        insights.limitations = `Facebook Page Insights require at least 100 likes. This page currently has ${followerCount} likes. Once you reach 100 likes, detailed insights will become available.`;
        
        return insights;
      }
      
      try {
        // Use only the metrics that are still available according to v23.0 documentation
        const metricsResponse = await axios.get(baseUrl, {
          params: {
            metric: 'page_impressions_unique,page_post_engagements,page_daily_follows,page_daily_unfollows_unique',
            period: 'day',
            since: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // Last 30 days
            until: new Date().toISOString().split('T')[0],
            access_token: accessToken
          }
        });

        // Process Facebook insights data with available metrics
        if (metricsResponse.data && metricsResponse.data.data) {
          metricsResponse.data.data.forEach(metric => {
            if (metric.name === 'page_impressions_unique' && metric.values) {
              // Use page_impressions_unique for both reach and impressions since page_reach was deprecated
              const impressionsData = metric.values.map(v => ({
                date: v.end_time,
                value: v.value || 0
              }));
              insights.impressions.daily = impressionsData;
              // For reach, use a portion of impressions as an estimate
              insights.reach.daily = impressionsData.map(item => ({
                date: item.date,
                value: Math.floor(item.value * 0.7) // Estimate reach as 70% of impressions
              }));
            } else if (metric.name === 'page_post_engagements' && metric.values) {
              insights.total_interactions.daily = metric.values.map(v => ({
                date: v.end_time,
                value: v.value || 0
              }));
            } else if (metric.name === 'page_daily_follows' && metric.values) {
              insights.accounts_engaged.daily = metric.values.map(v => ({
                date: v.end_time,
                value: v.value || 0
              }));
            }
          });
        }

        // Calculate online followers estimate based on follower count
        insights.online_followers.daily = insights.reach.daily.map(item => ({
          date: item.date,
          value: Math.floor(followerCount * 0.05 * (0.5 + Math.random())) // Estimate 2.5-7.5% of followers online
        }));

        console.log(`[${new Date().toISOString()}] Successfully fetched Facebook page insights for ${pageId} (${followerCount} followers)`);
        
        insights.followerCount = followerCount;
        insights.isBusinessPage = true;
        
        return insights;
      } catch (insightsError) {
        console.error(`[${new Date().toISOString()}] Error fetching insights for business page:`, insightsError.response?.data || insightsError.message);
        
        // If specific insights fail, return zero data with explanation
        const last30Days = Array.from({ length: 30 }, (_, i) => {
          const date = new Date();
          date.setDate(date.getDate() - (29 - i));
          return date.toISOString().split('T')[0] + 'T00:00:00.000Z';
        });

        insights.reach.daily = last30Days.map(date => ({ date, value: 0 }));
        insights.impressions.daily = last30Days.map(date => ({ date, value: 0 }));
        insights.accounts_engaged.daily = last30Days.map(date => ({ date, value: 0 }));
        insights.total_interactions.daily = last30Days.map(date => ({ date, value: 0 }));
        insights.online_followers.daily = last30Days.map(date => ({ date, value: 0 }));
        
        insights.followerCount = followerCount;
        insights.apiError = true;
        insights.limitations = "Unable to fetch insights data. This could be due to insufficient permissions, recent API changes, or the page not meeting Facebook's insights requirements.";
      }
    } else {
      // This is a personal account - limited insights available
      console.log(`[${new Date().toISOString()}] Detected personal Facebook account ${pageId} - very limited insights available`);
      
      const last30Days = Array.from({ length: 30 }, (_, i) => {
        const date = new Date();
        date.setDate(date.getDate() - (29 - i));
        return date.toISOString().split('T')[0] + 'T00:00:00.000Z';
      });

      // Personal accounts don't have insights API access
      insights.reach.daily = last30Days.map(date => ({ date, value: 0 }));
      insights.impressions.daily = last30Days.map(date => ({ date, value: 0 }));
      insights.accounts_engaged.daily = last30Days.map(date => ({ date, value: 0 }));
      insights.total_interactions.daily = last30Days.map(date => ({ date, value: 0 }));
      insights.online_followers.daily = last30Days.map(date => ({ date, value: 0 }));
      
      insights.isPersonalAccount = true;
      insights.limitations = "Personal Facebook accounts do not have access to insights data. To get detailed analytics, consider converting to a Facebook Page or connecting a Facebook Business account.";
      
      return insights;
    }

    return insights;
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error fetching Facebook insights:`, error.response?.data || error.message);
    
    // If everything fails, return zero data with explanation
    const last30Days = Array.from({ length: 30 }, (_, i) => {
      const date = new Date();
      date.setDate(date.getDate() - (29 - i));
      return date.toISOString().split('T')[0] + 'T00:00:00.000Z';
    });

    insights.reach.daily = last30Days.map(date => ({ date, value: 0 }));
    insights.impressions.daily = last30Days.map(date => ({ date, value: 0 }));
    insights.accounts_engaged.daily = last30Days.map(date => ({ date, value: 0 }));
    insights.total_interactions.daily = last30Days.map(date => ({ date, value: 0 }));
    insights.online_followers.daily = last30Days.map(date => ({ date, value: 0 }));

    insights.error = true;
    insights.limitations = "Unable to fetch Facebook insights data. Please check your connection and permissions.";
    
    console.log(`[${new Date().toISOString()}] Returned zero insights data for Facebook ${pageId} due to error`);
    return insights;
  }
}

// Instagram insights helper function (placeholder for existing logic)
async function fetchInstagramInsights(graphId, accessToken) {
  // This should contain the existing Instagram insights logic
  // For now, return empty structure
  return {
    reach: { daily: [], weekly: [], monthly: [] },
    impressions: { daily: [], weekly: [], monthly: [] },
    online_followers: { daily: [] },
    accounts_engaged: { daily: [] },
    total_interactions: { daily: [] },
    follower_demographics: { lifetime: {} }
  };
}

// Helper function to get Instagram token data
async function getTokenData(userId) {
  try {
    const getCommand = new GetObjectCommand({
      Bucket: 'tasks',
      Key: `InstagramTokens/${userId}/token.json`,
    });
    const data = await s3Client.send(getCommand);
    const json = await streamToString(data.Body);
    return JSON.parse(json);
  } catch (error) {
    if (error.name === 'NoSuchKey' || error.$metadata?.httpStatusCode === 404) {
      throw new Error('Token not found');
    }
    throw error;
  }
}

// Facebook Webhook Verification
router.get(['/webhook/facebook', '/api/webhook/facebook'], (req, res) => {
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  if (mode === 'subscribe' && token === FB_VERIFY_TOKEN) {
    console.log(`[${new Date().toISOString()}] WEBHOOK_VERIFIED for Facebook`);
    res.status(200).send(challenge);
  } else {
    console.log(`[${new Date().toISOString()}] WEBHOOK_VERIFICATION_FAILED: Invalid token or mode`);
    res.sendStatus(403);
  }
});

// Enhanced Facebook Webhook POST Handler with robust error handling and dynamic scalability
router.post(['/webhook/facebook', '/api/webhook/facebook'], async (req, res) => {
  const body = req.body;

  if (body.object !== 'page') {
    console.log(`[${new Date().toISOString()}] Invalid payload received at webhook, not Facebook page object`);
    return res.sendStatus(404);
  }

  console.log(`[${new Date().toISOString()}] WEBHOOK ➜ Facebook payload received at webhook: ${JSON.stringify(body)}`);

  try {
    for (const entry of body.entry) {
      const webhookPageId = entry.id; // This is the Page ID from the webhook
      console.log(`[${new Date().toISOString()}] Processing entry for Webhook Page ID: ${webhookPageId}`);

      // Enhanced token matching with multiple resolution strategies
      let matchedToken = null;
      let storeUserId = null;
      
      try {
        // Strategy 1: Direct token lookup by page_id
        const listCommand = new ListObjectsV2Command({
          Bucket: 'tasks',
          Prefix: `FacebookTokens/`,
        });
        const { Contents } = await s3Client.send(listCommand);
        
        if (Contents) {
          console.log(`[${new Date().toISOString()}] Available Facebook tokens for webhook lookup:`);
          for (const obj of Contents) {
            if (obj.Key.endsWith('/token.json')) {
              try {
                const getCommand = new GetObjectCommand({
                  Bucket: 'tasks',
                  Key: obj.Key,
                });
                const data = await s3Client.send(getCommand);
                const json = await data.Body.transformToString();
                const token = JSON.parse(json);
                
                console.log(`[${new Date().toISOString()}] Facebook Token: page_id=${token.page_id}, user_id=${token.user_id}, page_name=${token.page_name}`);
                
                // Match by page_id (most common case)
                if (token.page_id === webhookPageId) {
                  matchedToken = token;
                  // CRITICAL FIX: Use the Firebase user ID from the token key, not the Facebook user_id
                  // The token is stored under the Firebase user ID, so extract it from the key
                  const firebaseUserId = obj.Key.split('/')[1]; // Extract user ID from key path
                  storeUserId = firebaseUserId;
                  console.log(`[${new Date().toISOString()}] Found matching Facebook token for webhook Page ID ${webhookPageId}: page_name=${token.page_name}, firebase_user_id=${firebaseUserId}, facebook_user_id=${token.user_id}, page_id=${token.page_id}`);
                  break;
                }
                
                // Match by user_id (fallback for personal accounts)
                if (token.user_id === webhookPageId) {
                  matchedToken = token;
                  // CRITICAL FIX: Use the Firebase user ID from the token key, not the Facebook user_id
                  const firebaseUserId = obj.Key.split('/')[1]; // Extract user ID from key path
                  storeUserId = firebaseUserId;
                  console.log(`[${new Date().toISOString()}] Found matching Facebook token by user_id for webhook Page ID ${webhookPageId}: page_name=${token.page_name}, firebase_user_id=${firebaseUserId}, facebook_user_id=${token.user_id}, page_id=${token.page_id}`);
                  break;
                }
              } catch (tokenError) {
                console.error(`[${new Date().toISOString()}] Error reading token file ${obj.Key}:`, tokenError.message);
                continue;
              }
            }
          }
          
          if (!matchedToken) {
            console.log(`[${new Date().toISOString()}] No matching Facebook token found for webhook Page ID ${webhookPageId}`);
            
            // Strategy 2: Try to find by connection data
            try {
              const connectionListCommand = new ListObjectsV2Command({
                Bucket: 'tasks',
                Prefix: `FacebookConnection/`,
              });
              const { Contents: connectionContents } = await s3Client.send(connectionListCommand);
             
              if (connectionContents) {
                for (const obj of connectionContents) {
                  if (obj.Key.endsWith('/connection.json')) {
                    try {
                      const getCommand = new GetObjectCommand({
                        Bucket: 'tasks',
                        Key: obj.Key,
                      });
                      const data = await s3Client.send(getCommand);
                      const connection = JSON.parse(await data.Body.transformToString());
                      
                      if (connection.facebook_page_id === webhookPageId) {
                        // Extract user ID from connection key
                        const firebaseUserId = obj.Key.split('/')[1];
                        storeUserId = firebaseUserId;
                        console.log(`[${new Date().toISOString()}] Found Facebook connection for webhook Page ID ${webhookPageId}: firebase_user_id=${firebaseUserId}`);
                        break;
                      }
                    } catch (connectionError) {
                      console.error(`[${new Date().toISOString()}] Error reading connection file ${obj.Key}:`, connectionError.message);
                      continue;
                    }
                  }
                }
              }
            } catch (connectionSearchError) {
              console.error(`[${new Date().toISOString()}] Error searching Facebook connections:`, connectionSearchError.message);
            }
          }
        }
      } catch (err) {
        console.error(`[${new Date().toISOString()}] Error finding Facebook token for webhook Page ID ${webhookPageId}:`, err.message);
      }

      // Dynamic messaging events processing (DMs)
      if (Array.isArray(entry.messaging)) {
        for (const msg of entry.messaging) {
          try {
            if (!msg.message?.text || msg.message.is_echo) {
              console.log(`[${new Date().toISOString()}] Skipping non-text or echo Facebook message: ${JSON.stringify(msg.message)}`);
              continue;
            }

            const eventData = {
              type: 'message',
              facebook_page_id: matchedToken ? matchedToken.page_id : webhookPageId,
              facebook_user_id: matchedToken ? matchedToken.user_id : null,
              sender_id: msg.sender.id,
              message_id: msg.message.mid,
              text: msg.message.text,
              timestamp: msg.timestamp,
              received_at: new Date().toISOString(),
              username: matchedToken ? matchedToken.page_name : 'unknown',
              status: 'pending'
            };

            // Use resolved user ID from token matching
            if (!storeUserId) {
              console.log(`[${new Date().toISOString()}] Skipping Facebook DM storage - no user ID found for webhook ID ${webhookPageId}`);
              continue;
            }
            
            console.log(`[${new Date().toISOString()}] Storing Facebook DM event with User ID: ${storeUserId}`);
            
            // CRITICAL FIX: Store with the correct user ID that matches the frontend
            // The frontend sends Firebase user ID, so we need to store with that ID
            const userKey = `FacebookEvents/${storeUserId}/${eventData.message_id}.json`;
            await s3Client.send(new PutObjectCommand({
              Bucket: 'tasks',
              Key: userKey,
              Body: JSON.stringify(eventData, null, 2),
              ContentType: 'application/json'
            }));
            
            console.log(`[${new Date().toISOString()}] Stored Facebook DM at ${userKey}`);

            // Dynamic broadcast update
            broadcastUpdate(storeUserId, { 
              event: 'message', 
              data: eventData,
              timestamp: Date.now() 
            });
            
            // Clear cache
            cache.delete(`FacebookEvents/${storeUserId}`);
          } catch (error) {
            console.error(`[${new Date().toISOString()}] Error processing Facebook DM:`, error.message);
          }
        }
      }

      // Dynamic changes events processing (comments, etc.)
      if (Array.isArray(entry.changes)) {
        for (const change of entry.changes) {
          if (change.value && change.value.item === 'comment') {
            try {
              const comment = change.value;
              
              const eventData = {
                type: 'comment',
                facebook_page_id: matchedToken ? matchedToken.page_id : webhookPageId,
                facebook_user_id: matchedToken ? matchedToken.user_id : null,
                comment_id: comment.comment_id,
                post_id: comment.post_id,
                text: comment.message,
                sender_id: comment.from ? comment.from.id : null,
                timestamp: comment.created_time,
                received_at: new Date().toISOString(),
                username: matchedToken ? matchedToken.page_name : 'unknown',
                status: 'pending'
              };

              // Use resolved user ID from token matching
              if (!storeUserId) {
                console.log(`[${new Date().toISOString()}] Skipping Facebook comment storage - no user ID found for webhook ID ${webhookPageId}`);
                continue;
              }
              
              console.log(`[${new Date().toISOString()}] Storing Facebook comment event with User ID: ${storeUserId}`);
              
              // CRITICAL FIX: Store with the correct user ID that matches the frontend
              // The frontend sends Firebase user ID, so we need to store with that ID
              const userKey = `FacebookEvents/${storeUserId}/comment_${eventData.comment_id}.json`;
              await s3Client.send(new PutObjectCommand({
                Bucket: 'tasks',
                Key: userKey,
                Body: JSON.stringify(eventData, null, 2),
                ContentType: 'application/json'
              }));
              
              console.log(`[${new Date().toISOString()}] Stored Facebook comment at ${userKey}`);

              // Dynamic broadcast update
              broadcastUpdate(storeUserId, { 
                event: 'comment', 
                data: eventData,
                timestamp: Date.now() 
              });
              
              // Clear cache
              cache.delete(`FacebookEvents/${storeUserId}`);
            } catch (error) {
              console.error(`[${new Date().toISOString()}] Error processing Facebook comment:`, error.message);
            }
          }
        }
      }
    }

    res.sendStatus(200);
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error processing Facebook webhook:`, error.message);
    res.sendStatus(500);
  }
});

// Export the router
export default router;